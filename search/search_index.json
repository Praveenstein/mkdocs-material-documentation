{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Project Overview: Manufacturing Data Management</p> <p>This project focuses on streamlining data management in manufacturing plants. It aims to achieve the following:</p> <ol> <li> <p>Data Collection: Develop a system to gather data from manufacturing machines.</p> </li> <li> <p>Real-time Analytics: Provide real-time statistics on production processes.</p> </li> <li> <p>Documentation Integration: Seamlessly integrate document management for manufacturing.</p> </li> <li> <p>Open-Source and Interoperable: Use open-source technology and standards for compatibility.</p> </li> <li> <p>Security: Implement strong security measures for data protection.</p> </li> </ol> <p>This project aims to improve manufacturing efficiency and facilitate data sharing among companies. Feel free to ask for more details on any of these aspects.</p>"},{"location":"#requirements-of-the-project","title":"Requirements of the Project","text":"<p>The project requirements are:</p> <ul> <li> <p>Machine Maintenace - Machines (General purpose machines such as cnc and special purpose machines such as laser cladding) need to monitored for any abnormal conditions.</p> </li> <li> <p>Real Time Data Visualization Feature - A graphical way to visualize the data from all these machines.</p> </li> <li> <p>Spare Part Management - A system to monitor part count of machines and alerts system to notify maintenace team when a part of a machine needs to be replaced (which is monitored from a critical limit for the part).</p> </li> <li> <p>Alarm Management - A system to generate a summary of alarms for machines.</p> </li> <li> <p>Email Alerts &amp; Report Generation - A system to send email alerts when a machine is in abnormal state and to generate summart report of machines under abnormal states.</p> </li> </ul>"},{"location":"#nature-of-the-current-system-at-cmti-smart-manufacturing-demo-and-development-cell-smddc","title":"Nature of the Current System at CMTI Smart Manufacturing Demo and Development Cell ( SMDDC)","text":"<p>The following table gives the summary of available machines at CMTI's SMDDC:</p> S.No Machine Name Type Description Brand Model Location* Controller Name Controller Model Legacy Ip Address 1. Ace LT-2 Turning Center 2-axes horizontal turning centres Ace Micromatic LT-2-LM-500-PLUS R1 Fanuc 0i tf plus No 172.18.30.158 2. MONO 200 Turning Center MONO-200 is a CNC turning center machine Mac Power Mono 200 R2 Seimens sinumerik 828d No 172.18.28.35 3. AMS MCV - 450 Milling Center It's vertical machining center, It has a Fanuc 0i-MF plus CNC controller AMS(ACE MANUFACTURING SYSTEMS) MCV - 450 R3 Fanuc 0i - Mf Plus No 172.18.30.147 4. Mazak - H-400 N Milling Center Mazak H-400N is a horizontal machining center with a Seimens Controller Mazak H-400N R4 Seimens sinumerik 828D No 172.18.30.149 5. Mazak - H-400 N Milling Center Mazak H-400N is a horizontal machining center with a Fanuc Controller Mazak H-400N L4 Fanuc 0i -md TBA 6. Hmt - vtc 800, seimens Milling Center HMT VTC - 800 L3 Seimens TBA Yes 7. Schaublin 33 cnc Milling Center Schaublin Machines SA 33 CNC L2 Seimens 840D Yes 8. Hmt Stallion 200 Turning Center HMT Stallion L1 Fanuc ot - Series Yes <p>*The location should be viewed, as if the person is standing in SMDDC facing the main exit/entrace gate, so that NMTC building is on the left side.</p>"},{"location":"#features-of-the-project","title":"Features of the Project","text":"<p>The final product will be a web application with the following features:</p> <ul> <li>KPI Dashboard - This page of the web application will show the KPIs such as oee, availability, performance and quality for individual machines and factory.</li> <li> <p>Real Time Data Visualization Feature - This page of the web application will display time series data for a given machine, for a given parameter group, for a given axis within a given time range.</p> </li> <li> <p>Alarm Management Feature This page of the web application will display the summary of alarms and events for a given machine, during a given period of time range.</p> </li> <li> <p>Spare Part Management Feature This section of the web application will have information about the part count of machines, and information about the parts that needs to be replaced when a critical part limit is reached.</p> </li> <li> <p>Special Purpose Machines Feature This section of the web application will real time visualization of its parameters over a given range of time.</p> </li> </ul> <p>Apart from the web application, the final project solution should include the following services:</p> <ul> <li>4/8 Hour Summary Report Generation Service - A Service which generates a summary of machines that were under abnormal states for every 4/8 hour.</li> <li>Email Alerts Service - A Service which sends email alerts as soon as a machines goes to abnormal state.</li> </ul>"},{"location":"Code%20%26%20Services%20Locations/","title":"Code &amp; Services Location","text":""},{"location":"Code%20%26%20Services%20Locations/#introduction","title":"Introduction","text":"<p>This section shows the code locations and some of the services names and locations.</p>"},{"location":"Code%20%26%20Services%20Locations/#code-locations","title":"Code Locations","text":""},{"location":"Code%20%26%20Services%20Locations/#collector-services","title":"Collector Services","text":"<ol> <li> <p>Static Collector</p> <ul> <li> <p>Code Location</p> <pre><code>/home/tnga_iot/iiot_project/codes/collector_system/main_codes/collector_main_2/collector_main/main_static_collector.py\n</code></pre> </li> <li> <p>Service Name</p> <p>static_collector</p> </li> <li> <p>Service File Location (systemctl daemon file)</p> <pre><code>/lib/systemd/system/static_collector.service\n</code></pre> </li> </ul> </li> <li> <p>Dynamic Collector</p> <ul> <li> <p>Code Location</p> <pre><code>/home/tnga_iot/iiot_project/codes/collector_system/main_codes/collector_main_2/collector_main/main_dynamic_collector.py\n</code></pre> </li> <li> <p>Service Name</p> <p>dynamic_collector</p> </li> <li> <p>Service File Location (systemctl daemon file)</p> <pre><code>/lib/systemd/system/dynamic_collector.service\n</code></pre> </li> </ul> </li> <li> <p>Laser Cladding Collector</p> <ul> <li> <p>Code Location</p> <pre><code>/home/tnga_iot/iiot_project/codes/laser_cladding/laser_clad_main_2/laser_clad_main/main.py\n</code></pre> </li> <li> <p>Service Name</p> <p>laser_cladding_monitoring</p> </li> <li> <p>Service File Location (systemctl daemon file)</p> <pre><code>/etc/systemd/system/laser_cladding_monitoring.service\n</code></pre> </li> </ul> </li> <li> <p>Laser Cladding Collector B</p> <ul> <li> <p>Code Location</p> <pre><code>/home/tnga_iot/iiot_project/codes/laser_cladding/laser_cladding_b/laser_clad_main/main.py\n</code></pre> </li> <li> <p>Service Name</p> <p>laser_cladding_monitoring_b</p> </li> <li> <p>Service File Location (systemctl daemon file)</p> <pre><code>/etc/systemd/system/laser_cladding_monitoring_b.service\n</code></pre> </li> </ul> </li> <li> <p>SPM Journal Grinding Collector</p> <ul> <li> <p>Code Location</p> <pre><code>/home/tnga_iot/iiot_project/codes/collector_system/main_codes/collector_spm/codes/laser_clad_main/main_2.py\n</code></pre> </li> <li> <p>Service Name</p> <pre><code>journal_grinding_jop_X_collector\n</code></pre> </li> <li> <p>Service File Location JOP 105 (systemctl daemon file)</p> <pre><code>/etc/systemd/system/journal_grinding_jop_105_collector.service\n</code></pre> </li> <li> <p>Service File Location JOP 130 (systemctl daemon file)</p> <pre><code>/etc/systemd/system/journal_grinding_jop_130_collector.service\n</code></pre> </li> <li> <p>Service File Location JOP 140 (systemctl daemon file)</p> <pre><code>/etc/systemd/system/journal_grinding_jop_140_collector.service\n</code></pre> </li> </ul> </li> <li> <p>Part Count Collector</p> <ul> <li> <p>Code Location</p> <pre><code>/home/tnga_iot/iiot_project/codes/collector_system/main_codes/collector_part_count/tiei_main/main_part_count.py\n</code></pre> </li> <li> <p>Service Name</p> <p>part_count_collector</p> </li> <li> <p>Service File Location (systemctl daemon file)</p> <pre><code>/etc/systemd/system/part_count_collector.service\n</code></pre> </li> </ul> </li> <li> <p>Email Sender Service</p> <ul> <li> <p>Code Location</p> <pre><code>/home/tnga_iot/iiot_project/codes/collector_system/main_codes/collector_part_count/tiei_main/main_part_count.py\n</code></pre> </li> <li> <p>Service Name</p> <p>email_sender</p> </li> <li> <p>Service File Location (systemctl daemon file)</p> <pre><code>/etc/systemd/system/email_sender.service\n</code></pre> </li> </ul> </li> <li> <p>Summary Repory Generator Service</p> <ul> <li> <p>Code Location</p> <pre><code>/home/tnga_iot/iiot_project/codes/collector_system/main_codes/collector_part_count/tiei_main/main_part_count.py\n</code></pre> </li> <li> <p>Service Name</p> <p>report_summary_generator</p> </li> <li> <p>Service File Location (systemctl daemon file)</p> <pre><code>/etc/systemd/system/report_summary_generator.service\n</code></pre> </li> </ul> </li> </ol>"},{"location":"Code%20%26%20Services%20Locations/#back-end-services","title":"Back End Services","text":"<p>The back end in developed in FastApi and deployed as docker container. The codes are available in github and can be downloaded modified and dockerized to make any new changes.</p>"},{"location":"Code%20%26%20Services%20Locations/#front-end-services","title":"Front End Services","text":"<ol> <li>Apache Server</li> </ol> <p>The front end is developed using html, css, javascript and react. It is being served by apache server. The codes are available in github and can be downloaded modified and build using node package manager and copied to this location (which the apache server will serve)</p> <pre><code>/var/www/tnga_iot\n</code></pre>"},{"location":"Technical%20Stack/","title":"Technical Stack","text":""},{"location":"Technical%20Stack/#introduction","title":"Introduction","text":"<p>Based on the requirements and nature of the current system, the figure below shows the overall architecture of the proposed solution.</p> <pre><code>flowchart TB\n  subgraph MACHINES\n    direction TB\n      subgraph CNC[General Purpose CNC]\n      end\n      subgraph lc[Laser Cladding]\n      end\n      subgraph jg[Journal Grinding]\n      end\n  end\n  subgraph COLLECTOR\n    direction TB\n      subgraph MtC[MtLinki Collector]\n      end\n      subgraph lcc[Laser Cladding Collector]\n      end\n      subgraph jgc[Journal Grinding Collector]\n      end\n  end\n  subgraph DATABASE\n  end\n  CNC --MONGODB--&gt;MtC\n  lc --LOG FILES--&gt;lcc\n  jg --LOG FILES--&gt;jgc\n  COLLECTOR --&gt;DATABASE\n  DATABASE --&gt;BACKEND\n  BACKEND --&gt;FRONTEND\n  DATABASE --&gt;sum[4/8 HOUR SUMMARY REPORTS]\n  COLLECTOR --&gt;anomaly[ANOMALY DETECTION]\n  anomaly --&gt;abnormal[ABNORMALITY REPORTS]\n  COLLECTOR --&gt;part[PART COUNT MONITOR]\n  part --&gt;abnormal\n  part --&gt;DATABASE\n  abnormal --&gt;email\n  sum --&gt; email[EMAIL ALERTS]</code></pre>"},{"location":"Technical%20Stack/#implementation","title":"Implementation","text":"<p>All the requried services are developed using python script and deployed as linux daemon services.</p>"},{"location":"Technical%20Stack/#collectors","title":"Collectors","text":"<ul> <li> <p>MtLinki Collector</p> <ul> <li> <p>Static Collector - This service collects all new data from the MtLinki mongodb database for the 16 static parameter group.</p> </li> <li> <p>Dynamic Collector - This service collects all new data from the MtLinki mongodb database for the 1 dynamic (servo and spindle load) parameter group.</p> </li> </ul> </li> <li> <p>Lasser Cladding Collector - This service collects data from the laser cladding machine from its log files.</p> </li> <li> <p>Journal Grinding Collector - This service collects all new data from the journal grinding machine from its log files.</p> </li> </ul>"},{"location":"Technical%20Stack/#anomaly-detection","title":"Anomaly Detection","text":"<p>The anomaly detection for cnc machines are implemeted as part of the collector services.</p> <ul> <li> <p>Static Parameters - The anomaly detection for the 16 parameter groups are part of the static collector service and it works by simply checking if the current value of the parameters are within the normal working range.</p> </li> <li> <p>Dynamic Parameters - The anomaly detection for the 1 parameter group (Servo and Spindle load) are part of the dynamic collector service and it works using Kruskal\u2013Wallis one-way analysis of variance algorithm. This method compares the signal values for a new cycle with a reference signal, for any anomaly.</p> </li> </ul>"},{"location":"Technical%20Stack/#part-count-monitor","title":"Part Count Monitor","text":"<p>The machine part counts (for 59 cnc machines) are monitored from the parameter \"para name\". Once the reset button on the machine controller is pressed, the part count will be reset to zero. But to get a cumulative part count, we store the last part count value before the reset button was pressed, then whenever the part count is increased, the actual part count would be the part count before the press of reset button plus the current part count value. The formula for that is given below:</p> \\[ \\operatorname{} P_{A} = P_{Current} + P_{Cumulative}        ....... 1 \\] <p>Where, P<sub>A</sub> --&gt; Actual Part Count</p> <p>P<sub>Current</sub> --&gt; Current Part Count</p> <p>P<sub>Cumulative</sub> --&gt; Cumulative Part Count Before Press of Reset Button</p>"},{"location":"Technical%20Stack/#abnormality-reports","title":"Abnormality Reports","text":"<p>Different abnormalities are generated as an excel report as soon as they are recorded, and stored in a common location (Where the email alerts service will be looking for new report), these files will be deleted as soon as they are sent as email alerts by the email alerts services. The following things will create an abnormality report:</p> <ul> <li> <p>Static Parameter Abnormality - This will be recorded by the static collector as soon as any parameter goes beyond it's normal working range. A sample report is shown below.</p> </li> <li> <p>Dynamic Parameter Abnormality - This will be recorded by the dynamic collector as soon as any set of parameters belonging to a specific cycle is not similar to it's reference signal. A sample report is shown below.</p> </li> <li> <p>Part Count Alert - This will be recorded by the part count monitor as soon as any component of a machine exceeded it's part count limit and needs to be replaced. A sample report is shown below.</p> </li> </ul>"},{"location":"Technical%20Stack/#database","title":"Database","text":"<p>From the requirements and nature of current system, we've choosen timescale db as the database to store all the data. The entity relationship diargrams of all the table of the database is shown below:</p> <p></p> <p>The details of all the tables are given below:</p> <ol> <li> <p>Machine - This table will consist of data related to all the machines available at tiei new plant (including spm machines). The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>name</p> <ul> <li>Description - This is the name of the machine</li> <li>Type - String</li> </ul> </li> <li> <p>location</p> <ul> <li>Description - The location of the machine within the plant (crank, block, engine line)</li> <li>Type - String</li> </ul> </li> <li> <p>machine_number</p> <ul> <li>Description - This is the number of the machine.</li> <li>Type - String</li> </ul> </li> <li> <p>short_name</p> <ul> <li>Description - This is a short name for the machine</li> <li>Type - String</li> </ul> </li> <li> <p>description</p> <ul> <li>Description - This is a short description of the machine</li> <li>Type - String</li> </ul> </li> <li> <p>enabled</p> <ul> <li>Description - The columns is used to represent if the machine is enabled or not</li> <li>Type - Bool</li> </ul> </li> <li> <p>parameters</p> <ul> <li>Description - This gives the total number of parameters this machine has</li> <li>Type - Integer</li> </ul> </li> </ul> </li> <li> <p>Unit - This table will consist of data related to all the units of parameters of machines available at tiei new plant (including spm machines). The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>name</p> <ul> <li>Description - This is the name of the unit for a machine parameter</li> <li>Type - String</li> </ul> </li> <li> <p>short_name</p> <ul> <li>Description - This is a short name for the unit</li> <li>Type - String</li> </ul> </li> <li> <p>description</p> <ul> <li>Description - This is the short description of the unit</li> <li>Type - String</li> </ul> </li> <li> <p>type</p> <ul> <li>Description - TBA (To Be Addressed)</li> <li>Type - String</li> </ul> </li> </ul> </li> <li> <p>ParameterGroup - This table will consist of data related to all the groups of parameters (especially for the 59 cnc machines), such as apc battery, encoder temperature, etc. The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>mongodb_query</p> <ul> <li>Description - This is the regex pattern used to wildcard only the parameter names (as available in the Fanuc MtLinki Mongodb) belonging to the parameter group, for example \"load\" to query all servo and spindle loads (which belongs to dynamic parameter group). This is used internally by the collector services to query parameters from different groups.</li> <li>Type - String</li> </ul> </li> <li> <p>latest_update_time</p> <ul> <li>Description - This is the latest time for which new data was available for the parameter group as whole. For example ServoLoadOp150 has latest end time as time1 and SpindleLoadOP150 has end time as time2, the latest_update_time (for this parameter group would be) time2.</li> <li>Type - float</li> </ul> </li> <li> <p>warning_limit</p> <ul> <li>Description - This is the warning limit (only available for static parameters) (this will be used if in case the individual parameter doesn't have limits)</li> <li>Type - Integer</li> </ul> </li> <li> <p>critical_limit</p> <ul> <li>Description - This is the critical limit (only available for static parameters) (this will be used if in case the individual parameter doesn't have limits)</li> <li>Type - Integer</li> </ul> </li> <li> <p>parameter_type</p> <ul> <li>Description - This value is used to tell if the parameter (applicable only for static parameters) is of type increasing or decreasing. If increasing means, the critical limit value will be greater than warning limit, such as encoder temperature.</li> <li>Type - String</li> </ul> </li> </ul> </li> <li> <p>MachineParameter - This table will consist of data related to all the parameters of machines available at tiei new plant (including spm machines). The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>name</p> <ul> <li>Description - This is the name of the machine parameter</li> <li>Type - String</li> </ul> </li> <li> <p>machine_id</p> <ul> <li>Description - This is a foreign key, and refers to the id of Machines table, this shows the machine to which this parameter belongs to.</li> <li>Type - Integer</li> </ul> </li> <li> <p>warning_limit</p> <ul> <li>Description - This is the warning limit (only available for static parameters)</li> <li>Type - Integer</li> </ul> </li> <li> <p>critical_limit</p> <ul> <li>Description - This is the critical limit (only available for static parameters)</li> <li>Type - Integer</li> </ul> </li> <li> <p>reference_signal</p> <ul> <li>Description - This is the reference signal that are considers as good signal for this parameter (only available for dynamic parameters).</li> <li>Type - Array of Float</li> </ul> </li> <li> <p>parameter_group_id</p> <ul> <li>Description - This is a foreign key, refering to the id column of the ParameterGroup table, to represent the parameter group that this parameter belongs to.</li> <li>Type - Integer</li> </ul> </li> <li> <p>unit</p> <ul> <li>Description - This is a foreign key, refering to the id column of the Unit table, to represent the unit parameter has.</li> <li>Type - Integer</li> </ul> </li> <li> <p>parameter_type</p> <ul> <li>Description - This value is used to tell if the parameter (applicable only for static parameters) is of type increasing or decreasing. If increasing means, the critical limit value will be greater than warning limit, such as encoder temperature.</li> <li>Type - String</li> </ul> </li> </ul> </li> <li> <p>Event - This table will consist of data related to all events related to a machine, such as production, breakdown. The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>name</p> <ul> <li>Description - This is the name of the event.</li> <li>Type - String</li> </ul> </li> <li> <p>descrtiption</p> <ul> <li>Description - This is a short description of the event.</li> <li>Type - String</li> </ul> </li> </ul> </li> <li> <p>MachineEventTimeline - This table will consist of data related to all events timeline data related to a machine. This table is specifically used to store the event data related to spm machines (especially laser cladding machine). The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>start_time</p> <ul> <li>Description - This is the start time of the event.</li> <li>Type - Datetime</li> </ul> </li> <li> <p>end_time</p> <ul> <li>Description - This is the end time of the event.</li> <li>Type - Datetime</li> </ul> </li> <li> <p>duration</p> <ul> <li>Description - This is the duration of the event.</li> <li>Type - Timedelta</li> </ul> </li> <li> <p>event_id</p> <ul> <li>Description - This is a foreign key, and refers to the id column of Events table, this shows event to which this record of timeline data belongs to.</li> <li>Type - Integer</li> </ul> </li> <li> <p>machine_id</p> <ul> <li>Description - This is a foreign key, and refers to the id of Machines table, this shows the machine to which this parameter belongs to.</li> <li>Type - Integer</li> </ul> </li> </ul> </li> <li> <p>MachineProductionTimeline - This table will consist of data related to all production timeline data related to a machine. This table is specifically used to store the production data related to spm machines (especially laser cladding machine). The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>start_time</p> <ul> <li>Description - This is the start time of the production.</li> <li>Type - Datetime</li> </ul> </li> <li> <p>end_time</p> <ul> <li>Description - This is the end time of the production.</li> <li>Type - Datetime</li> </ul> </li> <li> <p>duration</p> <ul> <li>Description - This is the duration of the production.</li> <li>Type - Timedelta</li> </ul> </li> <li> <p>machine_event_timeline</p> <ul> <li>Description - This is a foreign key, and refers to the id column of MachineEventTimeline table, this shows event timeline to which this record of machine production timeline data belongs to.</li> <li>Type - Integer</li> </ul> </li> <li> <p>machine_id</p> <ul> <li>Description - This is a foreign key, and refers to the id of Machines table, this shows the machine to which this parameter belongs to.</li> <li>Type - Integer</li> </ul> </li> <li> <p>part_number</p> <ul> <li>Description - This is the part number of the component manufactured during this production cycle.</li> <li>Type - String</li> </ul> </li> </ul> </li> <li> <p>User - This table will consist of data related to all Users registered to access the web application. The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>username</p> <ul> <li>Description - This is the user name.</li> <li>Type - String</li> </ul> </li> <li> <p>email</p> <ul> <li>Description - This is the email id of the user.</li> <li>Type - String</li> </ul> </li> <li> <p>full_name</p> <ul> <li>Description - This is the full name of the user.</li> <li>Type - String</li> </ul> </li> <li> <p>disabled</p> <ul> <li>Description - This is a boolean variable used to check if the user is enabled or not</li> <li>Type - Bool</li> </ul> </li> <li> <p>hashed_password</p> <ul> <li>Description - This is the (hashed) password of the user.</li> <li>Type - String</li> </ul> </li> <li> <p>role</p> <ul> <li>Description - This is the role of the user.</li> <li>Type - String</li> </ul> </li> </ul> </li> <li> <p>EmailUser - This table will consist of data related to all Email Ids of users for whom email reports needs to sent. The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>username</p> <ul> <li>Description - This is the user name.</li> <li>Type - String</li> </ul> </li> <li> <p>email_id</p> <ul> <li>Description - This is the email id of the user that will receive email alerts.</li> <li>Type - String</li> </ul> </li> <li> <p>full_name</p> <ul> <li>Description - This is the full name of the user.</li> <li>Type - String</li> </ul> </li> <li> <p>disabled</p> <ul> <li>Description - This is a boolean variable used to check if the user is enabled or not</li> <li>Type - Bool</li> </ul> </li> <li> <p>hashed_password</p> <ul> <li>Description - This is the (hashed) password of the user.</li> <li>Type - String</li> </ul> </li> <li> <p>role</p> <ul> <li>Description - This is the role of the user.</li> <li>Type - String</li> </ul> </li> </ul> <p>Note</p> <p>If the user (of this application) wants to add or remove any email id that receives email alerts about abnormality, he/she needs to modify this table directly</p> </li> <li> <p>SparePart - This table will consist of data related to all Spare Parts of all the machines. The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>part_name</p> <ul> <li>Description - This is the part name.</li> <li>Type - String</li> </ul> </li> <li> <p>referenc_part_number</p> <ul> <li>Description - This is the cumulative part count of the machine, just before the press of reset button. This is the P<sub>Cumulative</sub> in equation 1.</li> <li>Type - String</li> </ul> </li> <li> <p>warning_limit</p> <ul> <li>Description - This is the warning part count limit.</li> <li>Type - Integer</li> </ul> </li> <li> <p>critical_limit</p> <ul> <li>Description - This is the critical part count limit.</li> <li>Type - Integer</li> </ul> </li> <li> <p>machine_id</p> <ul> <li>Description - This is a foreign key, and refers to the id of Machines table, this shows the machine to which this spare part belongs to.</li> <li>Type - Integer</li> </ul> </li> </ul> </li> <li> <p>MachinePartCount - This table will consist of part count data of all the machines. The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>part_signal_name</p> <ul> <li>Description - This is the signal/parameter name which holds the part count for the machine (as stored in the mongodb).</li> <li>Type - String</li> </ul> </li> <li> <p>current_part_count</p> <ul> <li>Description - This is the current part count for the machine (as denoted buy the machine column)</li> <li>Type - Integer</li> </ul> </li> <li> <p>last_reset_count</p> <ul> <li>Description - This is the part count of the machine just before the reset button was pressed. This is used to find the cumulative part count of machine, that is if the maachine part count was 500 just before the resetting it, then after that the cumulative part count would be 500 + 1, 500 + 2, and so on where 500 is your last_reset_count and 1/2 is your current_part_count.</li> <li>Type - Integer</li> </ul> </li> <li> <p>machine_id</p> <ul> <li>Description - This is a foreign key, and refers to the id of Machines table, this shows the machine to which this spare part belongs to.</li> <li>Type - Integer</li> </ul> </li> <li> <p>latest_update_time</p> <ul> <li>Description - This is the recent most timestamp during which the part count was updated (as stored in the mongodb).</li> </ul> </li> </ul> </li> <li> <p>ParameterCondition - This table will consist of data related to all conditions of a parameter, such as ok, warning and critical. The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>name</p> <ul> <li>Description - This is the condition name.</li> <li>Type - String</li> </ul> </li> </ul> </li> <li> <p>EventStaticMachineParameter - This table will consist of real time static data related to all events of a machine. This is specifically used for SPM machines (especially laser cladding). The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>value</p> <ul> <li>Description - This is the value of the parameter.</li> <li>Type - float</li> </ul> </li> <li> <p>machine_event_timeline_id</p> <ul> <li>Description - This is a foreign key, and refers to the id of MachineEventTimeline table, this shows the event timeline to which this event static machine parameter value belongs to.</li> <li>Type - Integer</li> </ul> </li> <li> <p>machine_parameter_id</p> <ul> <li>Description - This is a foreign key, and refers to the id of MachineParameter table, this shows the machine parameter to which this record of value belongs to.</li> <li>Type - Integer</li> </ul> </li> </ul> </li> <li> <p>RealTimeParameter - This table will consist of real time data related to all machine. The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>value</p> <ul> <li>Description - This is the value of the parameter.</li> <li>Type - float</li> </ul> </li> <li> <p>parameter_condition_id</p> <ul> <li>Description - This is a foreign key, and refers to the id of ParameterCondition table, this shows the condition to which this real time machine parameter value belongs to.</li> <li>Type - Integer</li> </ul> </li> <li> <p>machine_parameter_id</p> <ul> <li>Description - This is a foreign key, and refers to the id of MachineParameter table, this shows the machine parameter to which this record of value belongs to.</li> <li>Type - Integer</li> </ul> </li> </ul> <p>Note</p> <p>This is the main table where the actual parameter values are stored by all the collector services, for all machines, such as cnc machines, laser cladding, journal grinding. The EventStaticMachineParameter table also stores parameter values, but only those value which are fixed for a given cycle, they are used specifically for laser cladding, since it has some static parameters that don't change during the operating time. The cnc machines, and journal grinding machines don't have such setup and hence will not use this table.</p> </li> <li> <p>RealTimeParameterActive - This table will consist of the recent most data related to all machine. The details of it's columns are given below:</p> <ul> <li> <p>id</p> <ul> <li>Description - The prime identifier for any row within this table.</li> <li>Type - Integer</li> </ul> </li> <li> <p>value</p> <ul> <li>Description - This is the value of the parameter.</li> <li>Type - float</li> </ul> </li> <li> <p>parameter_condition_id</p> <ul> <li>Description - This is a foreign key, and refers to the id of ParameterCondition table, this shows the condition to which this real time machine parameter value belongs to.</li> <li>Type - Integer</li> </ul> </li> <li> <p>machine_parameter_id</p> <ul> <li>Description - This is a foreign key, and refers to the id of MachineParameter table, this shows the machine parameter to which this record of value belongs to.</li> <li>Type - Integer</li> </ul> </li> </ul> <p>Note</p> <p>This is the main table where the recent most value of parameters are stored by all the collector services, for all machines, such as cnc machines, laser cladding, journal grinding. This separate table allows us to optimize the performance while querying the recent most details about all machines, parameter groups, etc.</p> </li> </ol>"},{"location":"Technical%20Stack/#48-hour-summary-report","title":"4/8 Hour Summary Report","text":"<p>Every 4 hour (Starting from 5:30 AM) a summary of machines that were under abnormal condition are generated and saved as report in the directory 'directory location'. These reports are used by email service to send email alerts. A sample of the report is shown below:</p> <p></p>"},{"location":"Technical%20Stack/#email-alerts","title":"Email Alerts","text":"<p>An email service is deployed, which looks for new reports in the directory 'directory' every 5 second. As soon a new report is created in this directory it will be sent as email and deleted.</p>"},{"location":"Technical%20Stack/#back-end","title":"Back End","text":"<p>The back end is developed with python and fastapi framework, and ponyorm. The structure of the backend and description of the files and folders are explained in detail in the Code Explanation section.</p>"},{"location":"Technical%20Stack/#front-end","title":"Front End","text":"<p>The front end is developed with html, css, javascript and react framework. The structure of the frontend and description of the files and folders are explained in detail in the Code Explanation section.</p>"},{"location":"Troubleshoot_Faq/","title":"Troubleshooting &amp; FAQ","text":""},{"location":"Troubleshoot_Faq/#introduction","title":"Introduction","text":"<p>This section shows some of the common problems that you might face, and how to quickly solve them.</p>"},{"location":"Troubleshoot_Faq/#how-to-add-new-machine","title":"How to add new machine??","text":""},{"location":"Troubleshoot_Faq/#cnc-machine-with-mtlinki","title":"CNC machine with MtLinki","text":"<p>There are some modifications that need to be done to the collector</p> <ul> <li> <p>Collector:</p> <p>If the machine is already connected to the MtLinki, then there are few steps that needs to followed:</p> <ul> <li>STEP 1: Add the machine to the machines table</li> </ul> <p></p> <p>Note</p> <p>You can omit the id and enabled column while inserting (creating) a new machine, since these will be set to default values automcatically.</p> <ul> <li>STEP 2: Add its parameters to the machine_parameters table</li> </ul> <p></p> <p>Note</p> <p>You can omit the id column, omit the critical and warning limts if the parameter is of type dynamic, and omit reference signal if its of type static. Make sure to insert the correct machine_id (corresponds to the id of the machine created at previous step and can be found by querying from the machines table), parameter_group_id (refer to the parameters_group table to find the corresponding id for the paramter group), unit_id (corresponds to the row id of the units table, if the requried unit is not available create (insert) a new unit or use no units as temporary unit) and parameter type. And also make sure that you insert the parameters into the table in right order(corresponding to its axis names), it is the same order that you want it to be displayed in the front end or as given in the machining axis document. The parameter name should be same as the signalname in MtLinki Mongodb.The parameter name should be unique in the database, if the name is not unique, add the machine name along with the parameter, such as \"carrier gas_laser_cladding_jop199\".</p> <ul> <li>STEP 3: Restart the static and dynamic collector services (as shown in the following sections).</li> </ul> </li> <li> <p>Front End:</p> <p>All the information related to machines and their parameters can be configured by modifying the config.ts file.:</p> <ul> <li>STEP 1: Open the config.ts file</li> </ul> <p></p> <p>The config.ts file is located in the following location (the front end code needs to be downloaded from the github and opened in any editor) from the root directory of the project.</p> <pre><code>/src/models/configs.ts\n</code></pre> <ul> <li>STEP 2: Modify the config object</li> </ul> <p></p> <p>The config object in this file represents the configuration parameters for the front end elements. This object has a property machinetypes. This needs to be modified. This organizes the machines into sections, you can add new machine and their corresponding axis/parameters names under the corresponding section. For example to add new machine \"T_H_OP6666\", add the following code to the machines property under the section head.</p> <pre><code>{\n    \"name\": \"T_H_OP6666\",\n    \"axes\": [\"X\", \"Y\", \"Z\", \"X1\"]\n}\n</code></pre> <p>The key point to note is, the axes names should be ordered exactly how the appear (inserted) in the database, under the table machine_parameters, but the name could differ, such as ServoLoad_1_path1_T_H_OP6666 could be mapped to X1 (but the ordering should be same, i.e ServoLoad_1_path1_T_H_OP6666 should be the fourth parameter for this machine in this parameter group (servo and spinle load) when orderded(in ascending) by the id in the machine_paramters table)</p> <p></p> <ul> <li>STEP 3: Build the front end code and deploy.</li> </ul> <p>Run the following command (from your vs code terminal)</p> <p><pre><code>npm run build\n</code></pre> This will generate the build files.</p> <p>The contents of the build files need to be copied to the apache server location</p> <pre><code>/var/www/tnga_iot\n</code></pre> <p>Warning</p> <p>Copy the contents of the apache server directory to any new folder before moving the new build files, so that if the new build doesn't work as intened, you could replace it back with original files.</p> <p>Press ctrl + F5 , in the front to force refresh the web page to reflect the new changes. </p> </li> <li> <p>Back End:</p> <p>The back need to not be modified, it is self containted and reacts automatically to any changes happening to the collector and front end.</p> </li> </ul>"},{"location":"Troubleshoot_Faq/#spm-machines","title":"SPM machines","text":"<p>These machine need a more custom solution as detailed below.</p> <ul> <li> <p>Collector:</p> <p>The collector has to be developed based on how the data is available for the machine, it could be log files, proprietary api (such as haas mdc, fanuc focas). The user has to develop scripts to continuous monitor the machine for new data and add those data to the timescale database. There is no general script for it but there are certain guidelines that needs to be followed while developing the custom script for the spm machines.</p> <ul> <li>STEP 1: Add the machine to the machines table</li> </ul> <p></p> <p>Note</p> <p>You can omit the id and enabled column while inserting (creating) a new machine, since these will be set to default values automcatically.</p> <ul> <li>STEP 2: Add its parameters to the machine_parameters table</li> </ul> <p></p> <p>Note</p> <p>You can omit the id column, omit the critical and warning limts if the parameter is of type dynamic, and omit reference signal if its of type static. Make sure to insert the correct machine_id (corresponds to the id of the machine created at previous step and can be found by querying from the machines table), you can omit the parameter_group_id since they are not applicable for spm machines, unit_id (corresponds to the row id of the units table, if the requried unit is not available create (insert) a new unit or use no units as temporary unit) and parameter type ( \"spm_static\" for static paramter,and \"spm_dynamic\" for dynamic paramters). And also make sure that you insert the parameters into the table in right order(corresponding to its axis names), it is the same order that you want it to be displayed in the front end or as given in the machining axis document. The parameter name should be unique in the database, if the name is not unique, add the machine name along with the parameter, such as \"carrier gas_laser_cladding_jop199\".</p> <ul> <li> <p>STEP 3: Data format:</p> <p>The raw data from the machine, (either in log files or other format) need to be transformed to have four columns \"time\", \"machine_parameters_id\", \"value\", \"condition_id\", where the machine_parameters_id is the id of the row corresponding to the machine parameter in the machine parameters table, and condition id can take values \"1\", \"2\", or \"3\", corresponding to the id of rows from the parameter_conditions table. Once these format is transformed, they need to be inserted into real_time_machine_parameters table. For the real_time_machine_parameters_active table only the recent most data need to be updated. The key point is, the new data needs to be inserted/added to the real_time_machine_parameters table, but the recent most data need to replace the old data by updating the corresponding row (for that specific parameter) in the real_time_machine_parameters_active table.</p> </li> </ul> </li> <li> <p>Front End:</p> <p>All the information related to machines and their parameters can be configured by modifying the config.ts file.:</p> <ul> <li>STEP 1: Open the config.ts file</li> </ul> <p></p> <p>The config.ts file is located in the following location (the front end code needs to be downloaded from the github and opened in any editor) from the root directory of the project.</p> <pre><code>/src/models/configs.ts\n</code></pre> <ul> <li>STEP 2: Modify the config object</li> </ul> <p></p> <p>The config object in this file represents the configuration parameters for the front end elements. This object has a property machinetypes. This needs to be modified. This organizes the machines into sections, you can add new machine and their corresponding axis/parameters names under the corresponding section. For example to add new machine \"T_H_OP6666\", add the following code to the machines property under the section head.</p> <pre><code>{\n    \"name\": \"T_H_OP6666\",\n    \"axes\": [\"X\", \"Y\", \"Z\", \"X1\"]\n}\n</code></pre> <p>The key point to note is, the axes names should be ordered exactly how the appear (inserted) in the database, under the table machine_parameters, but the name could differ, such as ServoLoad_1_path1_T_H_OP6666 could be mapped to X1 (but the ordering should be same, i.e ServoLoad_1_path1_T_H_OP6666 should be the fourth parameter for this machine in this parameter group (servo and spinle load) when orderded(in ascending) by the id in the machine_paramters table)</p> <p></p> <ul> <li> <p>STEP 3: Build the front end code and deploy.</p> <p>Run the following command (from your vs code terminal)</p> <p><pre><code>npm run build\n</code></pre> This will generate the build files.</p> <p>The contents of the build files need to be copied to the apache server location</p> <pre><code>/var/www/tnga_iot\n</code></pre> <p>Warning</p> <p>Copy the contents of the apache server directory to any new folder before moving the new build files, so that if the new build doesn't work as intened, you could replace it back with original files.</p> <p>Press ctrl + F5 , in the front to force refresh the web page to reflect the new changes. </p> </li> </ul> </li> <li> <p>Back End:</p> <p>The back need to not be modified, it is self containted and reacts automatically to any changes happening to the collector and front end.</p> </li> </ul>"},{"location":"Troubleshoot_Faq/#how-to-change-anomaly-detection-algorithm-for-dynamic-parameters","title":"How to change anomaly detection algorithm for dynamic parameters??","text":"<p>All the anomaly detection task are carried out in the module anomaly_detection within the main application (be it cnc data collector, laser cladding collector etc).</p> <p>The structure of that module is shown below:</p> <p></p> <p></p> <p>As seen in the above pictures the function that carries out the detection method (kruskal method here) is implemented in the detection_algorithm.py script</p> <p>The contents of this function can be changed to use a different algorithm.</p> <p>Warning</p> <p>Do not change the function name (even if the new algorithm has different name) to ease out the transition to new algorithm.</p> <p>Any new algorithm should follow the following guidelines:</p> <ul> <li> <p>It Should accept a refence signal</p> </li> <li> <p>It should accept sample signal</p> </li> <li> <p>It should accept a threshold value (if not can use a default value of zero)</p> </li> <li> <p>Should return 3 if the condition of the sample signal is classified as abnormal/critical</p> </li> <li> <p>Should return 2 if the condition of the sample signal is classified as warning</p> </li> <li> <p>Should return 1 if the condition of the sample signal is classified as normal</p> </li> </ul> <p>This function is used in the following places as shown below</p> <p></p> <p></p> <p></p> <p>If in case you want to change the algorithm to other advanced algorithm, with different set of arguments, then you could change the function (and its name) and call that function with appropriate signature in the above mentioned places.</p>"},{"location":"Troubleshoot_Faq/#how-to-remove-existing-axisparameter-of-a-machine","title":"How to remove existing axis/parameter of a machine??","text":""},{"location":"Troubleshoot_Faq/#cnc-machine-with-mtlinki_1","title":"CNC machine with MtLinki","text":"<p>There are some modifications that need to be done to the timescale db</p> <ul> <li> <p>Timescale DB:</p> <ul> <li> <p>STEP 1: Delete all realtime data and realtime active data corresponding to the axis/parameter:</p> <p>The corresponding parameter's id needs to found and their records in the real_time_machine_parameters and real_time_machine_parameters_active table needs to be deleted</p> <p>Use the following code to find the id of the parameter:</p> <pre><code>SELECT id, name, warning_limit, critical_limit, reference_signal, unit_id, parameter_group_id, machine_id, parameter_type\n    FROM tiei_sample_4.machine_parameters\nWHERE name = 'CncFan1Speed_path1_T_B_OP180'\n</code></pre> <p>where you should replace CncFan1Speed_path1_T_B_OP180 with the actual name of the parameter as stored in MtLink in Mongodb.</p> <p>Use the following code to delete all the records from the realtime_machine_parameters tables:</p> <pre><code>DELETE FROM tiei_sample_4.real_time_machine_parameters\nWHERE machine_parameters_id = 163;\n</code></pre> <p>where you should replace 163 with the id of the parameter returned from the previous search.</p> <p>Use the following code to delete all the records from the realtime_machine_parameters_active tables:</p> <pre><code>DELETE FROM tiei_sample_4.real_time_machine_parameters_active\nWHERE machine_parameters_id = 163;\n</code></pre> <p>where you should replace 163 with the id of the parameter returned from the previous search.</p> <p>Warning</p> <p>Be cautious when using the above commands as they will delete all records from the table, if important parameter data are deleted, then they cannot be recovered.</p> <ul> <li>STEP 2: Delete the Parameter from MtLinki MongoDB</li> </ul> <p>This is important step, the parameter needs to be deleted from the mongodb also, else the collector will throw error.</p> <ul> <li>STEP 3: Restart the static and dynamic collector services (as shown in the following sections).</li> </ul> </li> </ul> </li> <li> <p>Front End:</p> <p>All the information related to machines and their parameters can be configured by modifying the config.ts file.:</p> <ul> <li> <p>STEP 1: Open the config.ts file</p> <p></p> <p>The config.ts file is located in the following location (the front end code needs to be downloaded from the github and opened in any editor) from the root directory of the project.</p> <pre><code>/src/models/configs.ts\n</code></pre> </li> <li> <p>STEP 2: Modify the config object</p> <p></p> <p>The config object in this file represents the configuration parameters for the front end elements. This object has a property machinetypes. This needs to be modified. This organizes the machines into sections, you can remove axis/parameters names under the corresponding section. For example to remove \"X\" axis from the machine \"T_H_OP6666\", the following modification has to be done to the machines property under the section head.</p> <ol> <li> <p>Before</p> <pre><code>    {\n        \"name\": \"T_H_OP6666\",\n        \"axes\": [\"X\", \"Y\", \"Z\", \"X1\"]\n    }\n</code></pre> </li> <li> <p>After</p> <pre><code>    {\n        \"name\": \"T_H_OP6666\",\n        \"axes\": [\"Y\", \"Z\", \"X1\"]\n    }\n</code></pre> </li> </ol> </li> <li> <p>STEP 3: Build the front end code and deploy.</p> <p>Run the following command (from your vs code terminal)</p> <p><pre><code>npm run build\n</code></pre> This will generate the build files.</p> <p>The contents of the build files need to be copied to the apache server location</p> <pre><code>/var/www/tnga_iot\n</code></pre> <p>Warning</p> <p>Copy the contents of the apache server directory to any new folder before moving the new build files, so that if the new build doesn't work as intened, you could replace it back with original files.</p> <p>Press ctrl + F5 , in the front to force refresh the web page to reflect the new changes.  - Back End:</p> </li> </ul> <p>The back need to not be modified, it is self containted and reacts automatically to any changes happening to the collector and front end.</p> </li> </ul>"},{"location":"Troubleshoot_Faq/#how-to-restart-services-and-check-it-status","title":"How to restart services (and check it status)??","text":""},{"location":"Troubleshoot_Faq/#check-the-status","title":"Check the Status","text":"<p>The following code can be used to check the status of any service</p> <pre><code>systemctl status static_collector\n</code></pre> <p>You could replace the static_collector with the service you want to check.</p> <p>The following images shows the result of using that command</p> <p></p> <p></p> <p>You shall press ctrl + c to get back your terminal from the service status (if required).</p>"},{"location":"Troubleshoot_Faq/#restart-the-service","title":"Restart the Service","text":"<p>The following code can be used to restart any service</p> <pre><code>systemctl restart static_collector\n</code></pre> <p>You could replace the static_collector with the service you want to restart.</p> <p>Tip</p> <p>Once in a while you can check the status of all services, or if in case there is any issue you can check all the services and try restarting any service that is inactive/dead. If nothing else works, you can always contact CMTI, We're happy to help! \ud83d\ude03 \ud83e\udd1d\ud83c\udffb</p>"},{"location":"user_interfaces/","title":"User Interface","text":"<p>This section gives the details about the user interface for the implemented solution. It gives details about all the functionalites of available features and steps to carry out certain task.</p>"},{"location":"user_interfaces/#maintenance-section","title":"Maintenance Section","text":"<p>There are two sections within the maintenacnce section,</p> <ul> <li> <p>A section to show the states of all parameter group, production line, machine, and it's parameters</p> </li> <li> <p>A section that shows the realtime data (time vs axis/parameter). This can be accessed by clicking on the axis (tiny rectangular box withing the machine infomation card)</p> </li> </ul>"},{"location":"user_interfaces/#machine-state-page","title":"Machine State Page","text":"<p>The screens that shows that states of differenet element are shown below.</p> <p></p> <p>This section shows the machine state of the 59 general purpose cnc machines. The main element in the screeen is your information card for the machines (rectangular box). It has two set of attributes</p> <ul> <li> <p>Machine Name - This represents the full name of the machine, such as OP180A (without the production line name).</p> </li> <li> <p>Parameter/Axis Name - The different axis are represented by the smaller rectangular box within the information card right below the machine name, they typically consist of 1, 2 or 3 letter symbols.</p> </li> </ul> <p>Each of the machines are grouped based on the production line such as head, crank and block.</p> <p>This screen shows four type of states:</p> <ul> <li> <p>Machine Level State - Each of the machine (as represented by the rectangular information box) will change its color based upon the current state of all the parameters/axis it has.</p> </li> <li> <p>Axis Level State - Each of the machine axis (as represented by the smaller rectangular information box) will change its color based upon it's current state.</p> </li> <li> <p>Line Level State - Each of the production line (as represented by the bigger and transparent rectangular information box) will change its color based upon the current state of all the machines in it's production line.</p> </li> <li> <p>Parameter Group Level State - Each of the parameter group (as represented by the rectangular information box at the bottom of the page) will change its color based upon the state of the machines in a particular group such as encoder temperature.</p> </li> </ul> <p>for all the above state, red represents a critical state, yellow represents a warning state and green repersents an normal state.</p> <p>The different sub sections of this maintenace section is explained below (as numbered in the image above)</p> <ol> <li> <p>Parameter Name : This shows the parameter group name, such as encoder temperature, apc battery, etc</p> </li> <li> <p>Machine State Summary : This shows the summary of the states of all machines, it gives the total number of machines in the three different states.</p> </li> <li> <p>Logged In User Details : This shows the current user logged in. You can use that to log out from the current session.</p> </li> <li> <p>Current Section Selected : This shows the current section (of the web application) that is selected.</p> </li> <li> <p>Parameter/Axis State : This shows the current state of the parameter/axis (Critical).</p> </li> <li> <p>Machine State Information Card : This shows the current status of the machine.</p> </li> <li> <p>Parameter/Axis State : This shows the current state of the parameter/axis (Warning) that belongs to the machine.</p> </li> <li> <p>Line State Information Card : This shows the name of the production line.</p> </li> <li> <p>Line State Information Card : This shows the current state of the production line.</p> </li> <li> <p>Parameter Group State Summary : This shows the current state of the different parameter groups that belongs to the machine.</p> </li> </ol>"},{"location":"user_interfaces/#real-time-graph","title":"Real Time Graph","text":"<p>The screens that shows the real time data (for static parameter) is shown below</p> <p></p> <p>The different sub sections of this maintenace section is explained below (as numbered in the image above)</p> <ol> <li> <p>Parameter Name : This shows the parameter group name, prorduction line, machine name and axis/parameter name.</p> </li> <li> <p>Warning Limit : This shows the current warning limit of this parameter.</p> </li> <li> <p>Warning Limit Set Button : This is the button used to set/change the warning limit for the current parameter.</p> </li> <li> <p>Critical Limit : This shows the current critical limit of this parameter</p> </li> <li> <p>Critical Limit Set Button : This is the button used to set/change the critical limit for the current parameter.</p> </li> <li> <p>Graph Title : This shows the title of the graph.</p> </li> <li> <p>Start Time Query Selector : This is used to select the start time of your query to get the real time data.</p> </li> <li> <p>End Time Query Selector : This is used to select the end time of your query to get the real time data.</p> <p>Note</p> <p>If data is not available for the given time range, the recent most available data is given. Only in the case where the parameter has no data recorded ever, it will throw a warning.</p> </li> <li> <p>Query Submit Button : This is the button used to submit your query for real time data.</p> </li> <li> <p>Detailed Graph Information Card : This information card shows the x and y axis names, units, and the current value of x and y axis when you hover the mouse over the graph.</p> </li> </ol> <p>The screens that shows the real time data (for dynamic parameter) is shown below</p> <p></p> <p>The different sub sections of this maintenace section is explained below (as numbered in the image above)</p> <ol> <li>Add/Edit Limits : This button is used to add (new or remove and replace existing) or append (to already existing) reference signal to the dynamic parameter.</li> </ol>"},{"location":"user_interfaces/#alarm-monitoring-section","title":"Alarm Monitoring Section","text":"<p>There section has one table to give the list of alarms for the selected machine in given time range, and three graphs:</p> <ul> <li> <p>Alarm Count Vs Alarms - This shows a parito graph between the total count of alarms and the alarm (name), for the selected machine and time range.</p> </li> <li> <p>Alarm Timespan Vs Alarms - This shows a parito graph between the total time (in seconds) of alarms and the alarm (name), for the selected machine and time range.</p> </li> <li> <p>Alarm Timespans - This shows a pi chart of the different alarms according to their total alarm timespan in seconds.</p> </li> </ul>"},{"location":"user_interfaces/#alarm-table","title":"Alarm Table","text":"<p>The screens that shows the alarm table is shown below</p> <p></p> <p>The different sub sections of this section is explained below (as numbered in the image above)</p> <ol> <li> <p>Page Name : This shows the title of the page (Alarm Monitoring).</p> </li> <li> <p>Machine Selection : This drop down box allows you to select the list of available machines</p> </li> <li> <p>Date Query Type : This drop down box allows you to select the type of date query, such as last day, week, month or custom range.</p> </li> <li> <p>Start Time Query Selector : This is used to select the start time of your query to get the alarm data.</p> </li> <li> <p>End Time Query Selector : This is used to select the end time of your query to get the alarm time data.</p> </li> <li> <p>Query Submit Button : This is the button used to submit your query for alarm data.</p> </li> <li> <p>Table Name : This shows the title of the table.</p> </li> <li> <p>Pagnation Selector : This button allows the user to select the number of rows to be displayed in the table and the page number.</p> </li> </ol>"},{"location":"user_interfaces/#partio-graphs","title":"Partio Graphs","text":"<p>The screens that shows the partio graphs for the Alarm Count Vs Alarms and Alarm Timespan Vs Alarms are shown below</p> <p></p> <p>The different sub sections of this section is explained below (as numbered in the image above)</p> <ol> <li> <p>Graph Name : This shows the title of the graph.</p> </li> <li> <p>Hide/Reveal Button : This button is used to hide or reveal the graph.</p> </li> <li> <p>Legend : This shows the legend of the graph.</p> </li> </ol>"},{"location":"user_interfaces/#pi-chart","title":"Pi Chart","text":"<p>The screens that shows the pi chart for the Alarm Timespan are shown below:</p> <p></p> <p>The different sub sections of this section is explained below (as numbered in the image above)</p> <ol> <li> <p>Graph Name : This shows the title of the graph.</p> </li> <li> <p>Hide/Reveal Button : This button is used to hide or reveal the graph.</p> </li> <li> <p>Legend : This shows the legend of the graph.</p> </li> </ol>"},{"location":"user_interfaces/#spare-part-management","title":"Spare Part Management","text":"<p>This section is used for spare part management, it has two views:</p> <ul> <li> <p>Machine Details - This shows information card for all available machines and has a details button, which can be clicked to view the current status of it's spare part count.</p> </li> <li> <p>Machine Specific Spare Part Details - This shows all the available spare parts for the machine, it's current part count and part count of the spare parts.</p> </li> </ul>"},{"location":"user_interfaces/#all-machine-status","title":"All Machine Status","text":"<p>The screens that shows the machine details is shown below</p> <p></p> <p>The different sub sections of this section is explained below (as numbered in the image above)</p> <ol> <li> <p>Page Name : This shows the title of the page (Alarm Monitoring).</p> </li> <li> <p>Machine Details : This shows the details of the machine. The different color represents the state of the machine, where warning / critical means any one or more of the spare parts of the machine has reached the limit and needs to be replaced.</p> </li> <li> <p>Production Line Name : This shows the production line number.</p> </li> </ol>"},{"location":"user_interfaces/#machine-specific-spare-part-details","title":"Machine Specific Spare Part Details","text":"<p>The screens that shows the spare part details for a selected machine is shown below</p> <p></p> <p>The different sub sections of this section is explained below (as numbered in the image above)</p> <ol> <li> <p>Machine Name : This shows the prorduction line, machine name.</p> </li> <li> <p>Cumulative Part Count : This shows the total/cumulative part count of the machine (irrespective of the number of times the reset button was pressed in the machine).</p> </li> <li> <p>Current Part Count : This shows the current part count of the machine after the reset button was pressed.</p> </li> <li> <p>Lock/Unlock Button : This button is used to lock and unlock the modification of the spare part, to avoid accidental changes. This has be unlocked before resetting the spare part count.</p> </li> <li> <p>Add Part Button : This button is used to create a new spare part for the machine.</p> </li> <li> <p>Spare Part Warning Limit : This shows the warning limit for the spare part.</p> </li> <li> <p>Spare Part Critical Limit : This shows the critical limit for the spare part.</p> </li> </ol> <p>The screens that shows the spare part details for a selected machine after unlocking the table is shown below</p> <p></p> <p>The different sub sections of this section is explained below (as numbered in the image above)</p> <ol> <li> <p>Delete Spare Part Button : This button is used to delete the spare part from the database.</p> </li> <li> <p>Current Spare Part Count : This shows the number of parts produced by the machine (irrespective of the number of time the reset button was pressed, since it take the cumulative value) since the spare part was created in the front end or since the reset button was pressed.</p> </li> <li> <p>Spare Part Counter Reset Button : This button is used to reset the spare part count (to zero). This should be used once the part has been replaced in the machine.</p> </li> <li> <p>Spare Part Warning Limit : This button can be used to set the warning limit for this spare part (activated only after the table is unlocked).</p> </li> <li> <p>Spare Part Critical Limit : This button can be used to set the critical limit for this spare part (activated only after the table is unlocked).</p> </li> </ol>"},{"location":"user_interfaces/#spm-machines","title":"SPM Machines","text":"<p>This section is used for management of SPM machines, it has two views:</p>"},{"location":"user_interfaces/#all-spm-machine-details","title":"All SPM Machine Details","text":"<p>This shows information card for all available SPM machines and has a details button, which can be clicked to view the current status of its parameters as shown in the above image. The information card is highlighted in different colors (green ,orange, red) corresponding to it's (it's parameters) state.The different sub sections of this section is explained below (as numbered in the image above):</p> <ol> <li>Machine Status  This shows the machine name, along with its status (color coded)</li> </ol>"},{"location":"user_interfaces/#machine-specific-details","title":"Machine Specific Details","text":"<p>This shows the real time graph for the spm. It can display three information</p> <p>Static Parameter - All the parameters (both static and dynamic) are combined under parameters section, the static parameters will have critical and warning limits. The sample screen is shown below, The different sub sections of this section is explained below (as numbered in the image below).</p> <p></p> <ol> <li> <p>Machine Name : This shows the machine name.</p> </li> <li> <p>Limit Setter : This shows the current limits, and also allows the user to set the limits.</p> </li> <li> <p>Query Submitter : This shows button is used to submit a real time data query.</p> </li> <li> <p>Machine Parameter : This shows the parameter name, and it's condition (color coded by the box below the parameter name), there is a small check box (to the left of the parameter name) that allows the user to select the parameter that needs to be displayed.</p> </li> <li> <p>Legend : This shows the legend for the graph, (as the user hovers over the graph, the values will be displayed over here)</p> </li> </ol> <p>Dynamic Parameter - All the parameters (both static and dynamic) are combined under parameters section, the dynamic parameters will have button to add edit reference signal. The sample screen is shown below, The different sub sections of this section is explained below (as numbered in the image below)</p> <p></p> <ol> <li>Add/Edit Limits :  This button is used to add (new or remove and replace existing) or append (to already existing) reference signal to the dynamic parameter.</li> </ol> <p>Position Based Query - The sample screen is shown below, The different sub sections of this section is explained below (as numbered in the image below)</p> <p></p> <ol> <li> <p>Add/Edit Limits :  This button is used to add (new or remove and replace existing) or append (to already existing) reference signal to the dynamic parameter.</p> <p>Note</p> <p>This screen is applicable only for laser cladding.</p> </li> </ol>"},{"location":"user_interfaces/#user-management","title":"User Management","text":"<p>This section is used for user management:</p> <p>The screens that shows the user details is shown below</p> <p></p> <p>The different sub sections of this section is explained below (as numbered in the image above)</p> <ol> <li> <p>Delete Button : This button is used to delete the user</p> <p>Note</p> <p>The admin user \"cmti\" cannot be deleted, for safety purposes.</p> </li> <li> <p>Add User Button : This button is used to add new user to the database</p> </li> </ol>"},{"location":"Code%20Explanation/Back%20End/","title":"Back End","text":""},{"location":"Code%20Explanation/Back%20End/#introduction","title":"Introduction","text":"<p>The requirements for the back end are:</p> <ol> <li> <p>anyio==3.5.0</p> </li> <li> <p>asgiref==3.5.1</p> </li> <li> <p>bcrypt==3.2.2</p> </li> <li> <p>cffi==1.15.1</p> </li> <li> <p>click==8.1.3</p> </li> <li> <p>colorama==0.4.4</p> </li> <li> <p>cryptography==37.0.4</p> </li> <li> <p>databases==0.5.5</p> </li> <li> <p>ecdsa==0.18.0</p> </li> <li> <p>et-xmlfile==1.1.0</p> </li> <li> <p>fastapi==0.75.2</p> </li> <li> <p>greenlet==1.1.2</p> </li> <li> <p>h11==0.13.0</p> </li> <li> <p>idna==3.3</p> </li> <li> <p>motor==3.0.0</p> </li> <li> <p>numpy==1.22.4</p> </li> <li> <p>openpyxl==3.0.10</p> </li> <li> <p>pandas==1.4.2</p> </li> <li> <p>passlib==1.7.4</p> </li> <li> <p>pony==0.7.16</p> </li> <li> <p>psycopg2==2.9.3</p> </li> <li> <p>pyasn1==0.4.8</p> </li> <li> <p>pycparser==2.21</p> </li> <li> <p>pydantic==1.9.0</p> </li> <li> <p>pymongo==4.1.1</p> </li> <li> <p>python-dateutil==2.8.2</p> </li> <li> <p>python-dotenv==0.20.0</p> </li> <li> <p>python-jose==3.3.0</p> </li> <li> <p>python-multipart==0.0.5</p> </li> <li> <p>pytz==2022.1</p> </li> <li> <p>rsa==4.9</p> </li> <li> <p>six==1.16.0</p> </li> <li> <p>sniffio==1.2.0</p> </li> <li> <p>SQLAlchemy==1.4.35</p> </li> <li> <p>sqlalchemy2-stubs==0.0.2a22</p> </li> <li> <p>sqlmodel==0.0.6</p> </li> <li> <p>starlette==0.17.1</p> </li> <li> <p>typing_extensions==4.2.0</p> </li> <li> <p>uvicorn==0.17.6</p> </li> <li> <p>XlsxWriter~=3.0.3</p> </li> <li> <p>schedule~=1.1.0</p> </li> </ol>"},{"location":"Code%20Explanation/Back%20End/#project-layout","title":"Project layout","text":"<pre><code>main.py                         # The main entry point for the fastapi backend\n                                # application.\nmachine_monitoring_app/\n    database/                   # This python package consist of modules related\n                                # to database.\n        __init__.py             # The Initialization file for the python package.\n        crud_operations.py      # This python module consist of functions to help\n                                # in database CRUD operations.\n        db_utils.py             # This python module consist of utility functions\n                                # to help in timescaledb operations.\n        mongo_db_utils.py       # This python module consist of utility functions\n                                # to help in mongodb operations.\n        mongodb_client.py       # This python module consist of functions to help\n                                # connect with mongodb.\n        pony_models.py          # This python module consist of classes for the\n                                # ORMs with timescaledb.\n    exception_handling/         # This python package consist of modules related\n                                # to exception handling.\n        __init__.py             # The Initialization file for the python package.\n        custom_exception.py     # This python module consist of classes for custom\n                                # exception handling.\n    models/                     # This python package consist of modules for the\n                                # pydantic classes.\n        __init__.py             # The Initialization file for the python package.\n        base_data_models.py     # The file consist of base pydantic models.\n        request_models.py       # The file consist of pydantic models that are used\n                                # for request body.\n        response_models.py      # The file consist of pydantic models that are used\n                                # for response body.\n    router/                     # The package consist of all endpoint of this backend.\n        __init__.py             # The Initialization file for the python package.\n        core_data_route.py      # The consist of core end points for this back end.\n        router_dependencies.py  # The file consist of functions to help other end points\n                                # Such as user authentication using jwt tokens.\n        security_routes.py      # The file consist of endpoint for user creation\n                                # and login methods.\n    utils/                      # The package consist of utility modules\n        __init__.py             # The Initialization file for the python package.\n        configuration_helper.py # The consist of functions to help in configuration\n                                # Such as logger configuration, database configuration, and \n                                # Initial server configuration.\n        global_variables.py     # The file consist of function to return some common\n                                # Global variables.\n    __init__.py                 # The Initialization file for the python package.\n</code></pre>"},{"location":"Code%20Explanation/Back%20End/#api-endpoints","title":"API Endpoints","text":"<p>The back end exposes api's to carry out different functionalites of the web application. The end points are classified into two type, core data routes and security routes. They are explained below.</p>"},{"location":"Code%20Explanation/Back%20End/#core-data-route","title":"Core Data Route","text":"<p>These set of end points consist of all the core routes requrired for data access and manipulation.</p>"},{"location":"Code%20Explanation/Back%20End/#get-end-points","title":"Get End Points","text":"<p>These are end points used to access data.</p> <ol> <li> <p>/api/v1/machine-state/{parameterGroupId} - This end point is used to get the status of machines in the given parameter group (such as encoder temperature).</p> <ul> <li> <p>Input Parameter</p> <ul> <li>parameterGroupId - This is the id column from the table ParameterGroup to identify the parameter group this parameter belongs to (For example id 4 for group encoder temperature).</li> </ul> </li> <li> <p>Response Body - The response body will consist of dictionary of two important key values, the first one denotes the status of machines (that are in abnormal condition) and second one is the summary of status of all other parameter groups (17 groups)</p> </li> </ul> <pre><code>    {\n        \"param\": 4,\n        \"param_actual_name\": \"ENCODER_TEMPERATURE\",\n        \"machines\": [\n            {\n            \"name\": \"T_B_OP160\",\n            \"status\": 2,\n            \"axes\": [\n                {\n                \"name\": 1,\n                \"actual_name\": \"PulseCoderTemp_1_path1_T_B_OP160\",\n                \"last_update_time\": 1662514103,\n                \"value\": 55,\n                \"status\": 2\n                }\n            ]\n            },\n            {\n            \"name\": \"T_B_OP195A\",\n            \"status\": 2,\n            \"axes\": [\n                {\n                \"name\": 1,\n                \"actual_name\": \"PulseCoderTemp_1_path1_T_B_OP195A\",\n                \"last_update_time\": 1662514230,\n                \"value\": 53,\n                \"status\": 2\n                }\n            ]\n            }\n        ],\n        \"params_group_status\": [\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1\n        ]\n        }\n</code></pre> <p>Explanation for the response body is given below</p> <pre><code>    {\n        \"param\": \"This is the id of the parameter group in the parameter group table\",\n        \"param_actual_name\": \"Actual name of the parameter group\",\n        \"machines\": [\n            {\n            \"name\": \"Name of the machine\",\n            \"status\": \"Status of the machines, 1 - ok, 2-warning, 3-critical\",\n            \"axes\": [\n                {\n                \"name\": \"Axis Id\",\n                \"actual_name\": \"Actual name of the parameter as mentioned in the mongodb\",\n                \"last_update_time\": \"The recent most time when the parameter was updates\",\n                \"value\": \"Value of the parameter\",\n                \"status\": \"status of the axis/parameter\"\n                }\n            ]\n            }],\n        \"params_group_status\": \"List of length 17 with values either 1, 2 or 3 denoting the\n                        summary of status of all machines in that paramter group\"\n    }\n</code></pre> </li> <li> <p>/api/v1/{machineName}/{parameterGroupId}/{axisId} - This end point is used to get the real time data for a given machine, parameter group and axis.the given parameter group (such as encoder temperature).</p> <ul> <li> <p>Input Parameter</p> <ul> <li> <p>machineName - This is the name of the machine as recorded in the machines table.</p> </li> <li> <p>parameterGroupId - This is the id column from the table ParameterGroup to identify the parameter group this parameter belongs to (For example id 4 for group encoder temperature).</p> </li> <li> <p>axisId - This is the id as given in the machines axis translation file.</p> </li> </ul> </li> <li> <p>Response Body - The response body will consist of dictionary of two important key values, the first one denotes the real time data and second one denotes the timestamp of those data.</p> </li> </ul> <pre><code>    {\n        \"param\": 4,\n        \"axis\": 0,\n        \"machine\": \"T_B_OP160\",\n        \"start_time\": 1662512183000,\n        \"stop_time\": 1662512303000,\n        \"data\": [\n            36,\n            37,\n            36\n        ],\n        \"timestamps\": [\n            1662512183000,\n            1662512243000,\n            1662512303000\n        ],\n        \"critical_limit\": 60,\n        \"warning_limit\": 50\n        }\n</code></pre> <p>Explanation for the response body is given below</p> <pre><code>    {\n        \"param\": \"This is the id of the parameter group in the parameter group table\",\n        \"axis\": \"Axis Id\",\n        \"machine\": \"Machine name\",\n        \"start_time\": \"The start time of the returned data in epoch format\",\n        \"stop_time\": \"The end time of the returned data in epoch format\",\n        \"data\": \"List of real time data values\",\n        \"timestamps\": \"List of timestamps in epoch format for the above data points\",\n        \"critical_limit\": \"The critical limit value for this parameter\",\n        \"warning_limit\": \"This is the warning limit value for this parameter\"\n    }\n</code></pre> </li> <li> <p>/api/v1/{machineName}/alarms - This end point is used to get the summary of alarms for a given machine between given start and end time.</p> <ul> <li> <p>Input Parameter</p> <ul> <li> <p>machineName - This is the name of the machine as recorded in the machines table for which alarm summary is requried.</p> </li> <li> <p>startTime - This is the start time in epoch format for which a summary of the alarms is requried.</p> </li> <li> <p>endTime - This is the end time in epoch format for which a summary of the alarms is requried.</p> </li> </ul> </li> <li> <p>Response Body - The response body will consist of dictionary of three important key values, the first one denotes alarm count data and second one denotes the total timespan of alarms, third one denotes the timeline data for the alarms between the given start and end time.</p> </li> </ul> <pre><code>    {\n        \"data\": {\n            \"count_data\": [\n            {\n                \"message\": \"EMBEDDED ETHERNET ERROR DETECTION\",\n                \"total_count\": 122\n            },\n            {\n                \"message\": \"PMC ALARM\",\n                \"total_count\": 1\n            }\n            ],\n            \"timespan_data\": [\n            {\n                \"message\": \"EMBEDDED ETHERNET ERROR DETECTION\",\n                \"total_time\": 353688.5\n            },\n            {\n                \"message\": \"PMC ALARM\",\n                \"total_time\": 5\n            }\n            ],\n            \"timeline_data\": [\n            {\n                \"enddate_epoch_time\": 1655101839,\n                \"update_epoch_time\": 1655093313.5,\n                \"message\": \"EMBEDDED ETHERNET ERROR DETECTION\"\n            },\n            {\n                \"enddate_epoch_time\": 1653279888.5,\n                \"update_epoch_time\": 1653279883.5,\n                \"message\": \"PMC ALARM\"\n            }\n            ]\n        }\n    }\n</code></pre> <p>Explanation for the response body is given below</p> <pre><code>    {\n        \"data\": {\n            \"count_data\": [\n            {\n                \"message\": \"The alarm message\",\n                \"total_count\": \"The total number of times this alarm occured during the given time\"\n            }\n            ],\n            \"timespan_data\": [\n            {\n                \"message\": \"The alarm message\",\n                \"total_time\": \"The total number of seconds this alarm occured during the given time\"\n            }\n            ],\n            \"timeline_data\": [\n            {\n                \"enddate_epoch_time\": \"The enddate time of this alarm as mentioned in the mtlinki mongodb\",\n                \"update_epoch_time\": \"The updatedate time of this alarm as mentioned in the mtlinki mongodb\",\n                \"message\": \"The alarm message\"\n            }\n            ]\n        }\n    }\n</code></pre> </li> </ol>"},{"location":"Code%20Explanation/Back%20End/#post-end-points","title":"Post End Points","text":"<p>These are end points used to create new data.</p> <ol> <li> <p>/api/v1/{machineName}/{sparePart} - This end point is used to create new spare part for a machine.</p> <ul> <li> <p>Input Parameter</p> <ul> <li> <p>machineName - This is the name of the machine as recorded in the machines table for which new spare part needs to be created.</p> </li> <li> <p>sparePart - This is the name of the spare part that needs to be created for this machine.</p> </li> <li> <p>referencePartNumber - This is the reference part number (which is equivalent to the part number for the machine when the new part is created or the part count when reset button is pressed). This is used to get the relative part count for the specific spare part. For example if new spare part called \"spare part 1\" is created when the total part count of the machine is 1000, the reference part number would be 1000, if the total part count for the machine is increased to 1001, then the part count for this spare part would  be 1 (calculatd by subtracting the reference part count for the spare part from the total part count of the machine, 10001 - 1000 = 1 in this case)</p> </li> <li> <p>warningLimit - This is the warning limit for this spare part.</p> </li> <li> <p>criticalLimit - This is the critical limit for this spare part.</p> </li> </ul> </li> <li> <p>Response Body - If the creation of new spare part was succesful it returns the (same) input parameters that were given by the client.</p> </li> </ul> <pre><code>    {\n        \"id\": 1,\n        \"part_name\": \"Spart Part 1\",\n        \"reference_part_number\": 100,\n        \"warning_limit\": 1000,\n        \"critical_limit\": 1500,\n        \"machine_id\": 2,\n        \"count\": 0\n    }\n</code></pre> <p>Explanation for the response body is given below</p> <pre><code>    {\n        \"id\": \"This is the row id in the spare parts table in the postgresql\",\n        \"part_name\": \"The spare part name\",\n        \"reference_part_number\": \"This is the referecen part number\",\n        \"warning_limit\": \"Warning limit for this spare part\",\n        \"critical_limit\": \"Critical limit for this spare part\",\n        \"machine_id\": \"This is the row id corresponding to the machine in the machines table in postgresql\",\n        \"count\": \"This is the current part count for the spare part, initially it would be zero\"\n    }\n</code></pre> </li> </ol>"},{"location":"Code%20Explanation/Back%20End/#put-end-points","title":"Put End Points","text":"<p>These are end points used to update existing data.</p> <ol> <li> <p>/api/v1/{machineName}/{sparePart} - This end point is used to update an existing spare part for a machine.</p> <ul> <li> <p>Input Parameter</p> <ul> <li> <p>machineName - This is the name of the machine as recorded in the machines table for which new spare part needs to be created.</p> </li> <li> <p>sparePart - This is the name of the spare part that needs to be created for this machine.</p> </li> <li> <p>parameterName - This is shows which parameter we want to update for the spare part, it could either be reference part number, warning limit or critical limit.</p> </li> <li> <p>parameterValue - This is the parameter value.</p> </li> </ul> </li> <li> <p>Response Body - If the spare part was succesful updated it returns the parameters that were given by the client during the creation of the spare part.</p> </li> </ul> <pre><code>    {\n        \"id\": 1,\n        \"part_name\": \"Spart Part 1\",\n        \"reference_part_number\": 100,\n        \"warning_limit\": 1000,\n        \"critical_limit\": 1500,\n        \"machine_id\": 2,\n        \"count\": 10\n    }\n</code></pre> <p>Explanation for the response body is given below</p> <pre><code>    {\n        \"id\": \"This is the row id in the spare parts table in the postgresql\",\n        \"part_name\": \"The spare part name\",\n        \"reference_part_number\": \"This is the referecen part number\",\n        \"warning_limit\": \"Warning limit for this spare part\",\n        \"critical_limit\": \"Critical limit for this spare part\",\n        \"machine_id\": \"This is the row id corresponding to the machine in the machines table in postgresql\",\n        \"count\": \"This is the current part count for the spare part, initially it would be zero\"\n    }\n</code></pre> </li> <li> <p>/api/v1/parameters_limit/{machineName}/{parameterGroupId}}/{axisId} - This end point is used to update the warning /critical limits for the static parameter or to set new or update(append) reference signal for dynamic parameter.</p> <ul> <li> <p>Input Parameter</p> <ul> <li> <p>machineName - This is the name of the machine as recorded in the machines table whose parameter limits is to be set/updated.</p> </li> <li> <p>parameterGroupId - This is the id column from the table ParameterGroup to identify the parameter group this parameter belongs to (For example id 4 for group encoder temperature).</p> </li> <li> <p>axisId - This is the id as given in the machines axis translation file.</p> </li> <li> <p>setType - This is shows what parameter that the client is trying to set, it could be warning_limit, critical_limit, reference_signal.</p> </li> <li> <p>limit - This is the limit value.</p> </li> <li> <p>append - This tells if the client is trying to append new reference signal to existing reference signal (value should be true), or replace the existing reference signal with new signal (in this case the append parameter should be false). This is applicable only if the setType is reference_signal.</p> </li> </ul> </li> <li> <p>Request Body - This is a list of reference signal values, for example : [1, 2, 5, 8]</p> </li> <li> <p>Response Body - If the limits are sucessfully updated, it return the set type and value. <pre><code>    {\n        \"set_type\": \"warning_limit\",\n        \"value\": 55\n    }       \n</code></pre></p> </li> </ul> <p>Explanation for the response body is given below</p> <pre><code>    {\n        \"set_type\": \"The parameter set type\",\n        \"value\": \"The set value for the parameter\"\n    }       \n</code></pre> </li> </ol>"},{"location":"Code%20Explanation/Back%20End/#delete-end-points","title":"Delete End Points","text":"<p>These are end points used to delete data.</p> <ol> <li> <p>/api/v1/{machineName}/{sparePart} - This end point is used to delete an existing spare part for a machine.</p> <ul> <li> <p>Input Parameter</p> <ul> <li> <p>machineName - This is the name of the machine as recorded in the machines table for which a spare part needs to be deleted.</p> </li> <li> <p>sparePart - This is the name of the spare part that needs to be deleted for this machine.</p> </li> </ul> </li> <li> <p>Response Body - If returns a message regarding the success or failure of the operation.</p> </li> </ul> <pre><code>    {\n        \"detail\": \"Successfully Deleted\",\n        \"spare_part\": \"Spart Part 1\"\n    }\n</code></pre> <p>Explanation for the response body is given below</p> <pre><code>    {\n        \"detail\": \"Information whether the deletion was successful or not\",\n        \"spare_part\": \"Spart Part name\"\n    }\n</code></pre> </li> </ol>"},{"location":"Code%20Explanation/Back%20End/#security-route","title":"Security Route","text":"<p>These set of end points consist of all the routes requrired for security related operations.</p>"},{"location":"Code%20Explanation/Back%20End/#post-end-points_1","title":"Post End Points","text":"<p>These are end points used to post data.</p> <ol> <li> <p>/api/v1/auth - This end point is used to login a user and give JWT token for the session.</p> <ul> <li>Request Body</li> </ul> <pre><code>    {\n        \"username\": \"The user name\",\n        \"password\": \"The user's password\"\n    }\n</code></pre> <ul> <li>Response Body</li> </ul> <pre><code>    {\n        \"access_token\": \"eyJhbGiIsInR5cCI6IkpXVCJ9.ey6gH9RWI5D5PFjI\",\n        \"token_type\": \"bearer\"\n    }\n</code></pre> <p>Explanation for the response body is given below</p> <pre><code>    {\n        \"access_token\": \"The JWT token\",\n        \"token_type\": \"token type\"\n    }\n</code></pre> </li> <li> <p>/api/v1/register - This end point is used to register a new user, this can be done only be admin users.</p> <ul> <li>Request Body</li> </ul> <pre><code>    {\n        \"username\": \"new_user\",\n        \"email\": \"new_user@mail.com\",\n        \"full_name\": \"User Name\",\n        \"password\": \"password\"\n    }   \n</code></pre> <ul> <li>Response Body</li> </ul> <pre><code>    {\n        \"username\": \"user name\",\n        \"email\": \"email id of user\",\n        \"full_name\": \"Full name of user\"\n    }\n</code></pre> </li> </ol>"},{"location":"Code%20Explanation/Collector/","title":"Collector","text":""},{"location":"Code%20Explanation/Collector/#introduction","title":"Introduction","text":"<p>The collector consist of scripts to collect data from all different data sources at TIEI, such as general purpose cnc machines, spm machines such as laser cladding, journal grinding. It consist of 4 separate collector services:</p> <ul> <li> <p>Static Parameter Collector - This is used to collect data for static parameters</p> </li> <li> <p>Dynamic Parameter Collector - This is used to collect data for dynamic parameters</p> </li> <li> <p>SPM Parameter Collector - This is used to collect data for SPM machines</p> <ul> <li> <p>Laser Cladding - This is used to collect data from laser cladding machines</p> </li> <li> <p>Journal Grinding - This is used to collect data from Journal Grinding machines</p> </li> </ul> </li> <li> <p>Part Count Monitor/Collector - This is used to collect part count from all machines.</p> </li> </ul>"},{"location":"Code%20Explanation/Collector/#static-and-dynamic-collector","title":"Static and Dynamic Collector","text":""},{"location":"Code%20Explanation/Collector/#project-requirement","title":"Project Requirement","text":"<p>The requirements for the collector services are:</p> <ol> <li> <p>pandas~=1.4.2</p> </li> <li> <p>pymongo~=4.1.1</p> </li> <li> <p>psycopg2~=2.9.3</p> </li> <li> <p>pgcopy~=1.5.0</p> </li> <li> <p>yagmail~=0.15.277</p> </li> <li> <p>scipy~=1.8.1</p> </li> <li> <p>XlsxWriter~=3.0.3</p> </li> <li> <p>numpy~=1.23.0</p> </li> </ol>"},{"location":"Code%20Explanation/Collector/#project-layout","title":"Project layout","text":"<p>The following layout shows the general project structure for the Static and dynamic parameters (59 cnc machines) collectors.</p> <pre><code>main_static_collector.py            # The main entry point for the static collector service.\nmain_dynamic_collector.py           # The main entry point for the dynamic collector service.\nmain_report_sender.py               # The main entry point for the report generation service.\ncollector_app/\n    database/                       # This python package consist of modules related\n                                    # to database.\n        __init__.py                 # The Initialization file for the python package.\n        crud_operations.py          # This python module consist of functions to help\n                                    # in database CRUD operations.\n        db_utils.py                 # This python module consist of utility functions\n                                    # to help in timescaledb operations.\n        common_query_templates.py   # This python module consist of template for common queries.\n    exception_handling/             # This python package consist of modules related\n                                    # to exception handling.\n        __init__.py                 # The Initialization file for the python package.\n        custom_exception_classes.py # This python module consist of classes for custom\n                                    # exception handling classes.\n    anomaly_detection/              # This python package consist of modules for the\n                                    # anomaly detection.\n        __init__.py                 # The Initialization file for the python package.\n        detection_algorithm.py      # The file consist of function to do Kruskal\u2013Wallis test.\n    collector_classes/              # The package consist of modules that has collector classes.\n        __init__.py                 # The Initialization file for the python package.\n        collector_classes_module.py # The consist of core python classes that collect data.\n    report_manager/                 # The package consist of modules that for report generation.\n        __init__.py                 # The Initialization file for the python package.\n        email_Sender.py             # The consist of functions to generate reports for abnormality.\n    utils/                          # The package consist of utility modules\n        __init__.py                 # The Initialization file for the python package.\n        config_helper.py            # The consist of functions to help in configuration\n                                    # Such as logger configuration, database configuration\n        exception_handling.py       # The file consist of function for exception handling\n        global_variables.py         # The file consist of function to return some common\n                                    # Global variables.\n    __init__.py                     # The Initialization file for the python package.\n</code></pre> <p>The core functionalities for the collector services are implemeted in the collector classes, namely:</p> <ol> <li> <p>ParametersGroupBase - This is the class to represent the static parameter group such as encoder temperature. These have specific variables and methods to collect data from the MtLinki.L1SignalPoolActive for all the static parameters. These classes inherit from the ParametersGroupAbstract abstract class.</p> </li> <li> <p>DynamicParameters - This is the class to represent the dynamic parameter group such as spindleload. These have specific variables and methods to collect data from the MtLinki.L1SignalPool for all the dynamic parameters. These classes inherit from the ParametersGroupBase class, but have specific methods for the requriements of dynamic parameter.</p> </li> <li> <p>CollectorClass - This is the class that has variable and methods to use the ParametersGroupBase to represent the static parameters and orchestrate the collection of all static parameter group data.</p> </li> <li> <p>DynamicCollectorClass - This is the class that has variable and methods to use the DynamicParameters to represent the dynamic parameters and orchestrate the collection of all dynamic parameter group data.</p> </li> </ol> <p>The UML class diagram for the above classes are given the diagram below:</p> <pre><code>classDiagram\n  ParametersGroupAbstract &lt;|-- ParametersGroupBase\n  ParametersGroupBase     &lt;|-- DynamicParameters\n  CollectorClass          &lt;|-- DynamicCollectorClass\n  ParametersGroupAbstract : +String group_name\n  ParametersGroupAbstract : +String mongodb_query\n  ParametersGroupAbstract : +Int warning_limit\n  ParametersGroupAbstract : +Int critical_limit\n  ParametersGroupAbstract : +Float latest_update_time\n  ParametersGroupAbstract : +Float _temp_latest_update_time\n  ParametersGroupAbstract : +String parameter_type\n  ParametersGroupAbstract : +Pandas DataFrame recent_data\n  ParametersGroupAbstract : +Pandas DataFrame next_alert_time_for_all_signals\n  ParametersGroupAbstract : +Pandas DataFrame new_alerts\n  ParametersGroupAbstract : +check_for_new_data()\n  ParametersGroupAbstract : +get_new_data()\n  ParametersGroupAbstract : +add_condition_columns()\n  ParametersGroupAbstract : +insert_to_timescaledb()\n  ParametersGroupAbstract : +check_for_new_anomaly()\n  ParametersGroupAbstract : +send_alerts()\n  class DynamicParameters{\n    +check_dynamic_condition()\n  }\n  ParametersGroupBase     &lt;-- CollectorClass:has static parameter\n  DynamicParameters       &lt;-- DynamicCollectorClass:has dynamic parameter\n  class CollectorClass{\n    +String read_cycle_time\n    +String static_parameters\n    +String dynamic_parameters\n    +int combined_alerts\n    +load_parameters()  \n    +do_workflow()  \n    +merge_alerts()  \n    +send_combined_alerts()  \n    +start_collector()  \n  }</code></pre>"},{"location":"Code%20Explanation/Collector/#special-purpose-machines","title":"Special Purpose Machines","text":"<p>For all the spm machines, the pc which has the log files, is connected to the linux server through network, and the directory is continously monitored for new log files. As soon as a new file is generated, the services will read them and transforms the data to the timescaledb format and inserts them.</p>"},{"location":"Code%20Explanation/Collector/#project-requirement_1","title":"Project Requirement","text":"<p>The requirements for the laser cladding collector services are:</p> <ol> <li>numpy==1.22.3</li> <li>pandas==1.4.2</li> <li>pgcopy==1.5.0</li> <li>psycopg2==2.9.3</li> <li>python-dateutil==2.8.2</li> <li>pytz==2022.1</li> <li>six==1.16.0</li> </ol>"},{"location":"Code%20Explanation/Collector/#project-layout_1","title":"Project layout","text":"<p>The following layout shows the general project structure for all the SPM collectors.</p> <pre><code>main.py                             # The main entry point for the laser cladding collector.\napp/\n    database/                       # This python package consist of modules related\n                                    # to database.\n        __init__.py                 # The Initialization file for the python package.\n        crud_operations.py          # This python module consist of functions to help\n                                    # in database CRUD operations.\n        db_utils.py                 # This python module consist of utility functions\n                                    # to help in timescaledb operations.\n    data_transformation_Service/    # This python package consist of modules related\n                                    # to functions that does transformation of log files to \n                                    # Database format.\n        __init__.py                 # The Initialization file for the python package.\n        transformation_functions.py # This python module consist of function to do log file\n                                    # File transformation.\n    file_system_operation/          # This python package consist of modules for the\n                                    # directory monitoring.\n        __init__.py                 # The Initialization file for the python package.\n        directory_monitoring.py     # The file consist of function to monitor the machine for \n                                    # New log files.\n    initialization_services/        # The package consist of modules that has collector classes.\n        __init__.py                 # The Initialization file for the python package.\n        initial_setup.py            # The consist of functions to do initial set up of this service.\n    utils/                          # The package consist of utility modules\n        __init__.py                 # The Initialization file for the python package.\n        check_mount.py              # The consist of functions to check if the machine is\n                                    # Mounted as a connected device to the linux server\n        config_helper.py            # The file consist of function for configuration such as log, database\n        input_getter.py             # The file consist of function to get input from the command line\n    __init__.py                     # The Initialization file for the python package.\n</code></pre>"},{"location":"General%20Knowledge/Focas/","title":"Focas","text":""},{"location":"General%20Knowledge/Focas/#introduction","title":"Introduction","text":"<p>Fanuc Focas API is a programming interface provided by Fanuc, a leading manufacturer of industrial robots and CNC (Computer Numerical Control) systems. The Focas API allows developers to interact with and control Fanuc CNC systems using various programming languages. It provides a set of functions and commands that enable applications to retrieve information from CNC controllers, monitor machine status, send commands, and perform data exchanges with the CNC system. The Focas API is widely used in industries such as manufacturing, automation, and robotics to develop custom software solutions for Fanuc CNC machines.</p>"},{"location":"General%20Knowledge/Focas/#quick-overview-of-csharp-and-project-setup-in-visual-studio","title":"Quick Overview of Csharp and Project setup in Visual Studio","text":""},{"location":"General%20Knowledge/Focas/#introduction_1","title":"Introduction","text":"<p>In C# and .NET, projects are organized using solutions, which consist of one or more projects. This documentation provides an overview of the project structure and key concepts related to C# and .NET development.</p>"},{"location":"General%20Knowledge/Focas/#solutions","title":"Solutions","text":"<ul> <li>Solutions serve as containers for organizing multiple projects in C# and .NET development.</li> <li>A solution represents a higher-level unit that groups related projects together.</li> <li>Solutions provide a convenient way to manage dependencies and build configurations for complex software systems.</li> </ul>"},{"location":"General%20Knowledge/Focas/#projects","title":"Projects","text":"<ul> <li>Projects are the building blocks of a solution and contain the source code and other related files.</li> <li>A solution can have multiple projects, each representing a distinct component or module.</li> <li>Projects are typically used to organize and manage different aspects of the software solution.</li> </ul>"},{"location":"General%20Knowledge/Focas/#assemblies-and-dlls","title":"Assemblies and DLLs","text":"<ul> <li>Once a project is compiled, it produces assemblies or DLLs (Dynamic Link Libraries).</li> <li>Assemblies are the output files of the compilation process and contain executable code and other resources.</li> <li>Assemblies can be thought of as a group of related namespaces and types.</li> </ul>"},{"location":"General%20Knowledge/Focas/#namespaces","title":"Namespaces","text":"<ul> <li>Namespaces are used to organize and group related classes, interfaces, and other types within a project.</li> <li>Namespaces provide a way to avoid naming conflicts and provide logical separation between different components of the codebase.</li> <li>Namespaces make it easier to manage and navigate large codebases by providing a hierarchical structure.</li> </ul>"},{"location":"General%20Knowledge/Focas/#default-namespace-in-visual-studio","title":"Default Namespace in Visual Studio","text":"<ul> <li>By default, Visual Studio will create a namespace that matches the name of the project.</li> <li>The default namespace helps maintain a clear and consistent structure for the code within the project.</li> <li>Developers can modify the namespace to suit their needs, but it is generally recommended to keep it aligned with the project name.</li> </ul> <p>The following diagram shows the above hierarchy as an UML diagram</p> <pre><code>flowchart TB\n  subgraph SOLUTION\n    direction TB\n    Solution((Solution))\n    Solution --&gt; Project1\n    Solution --&gt; Project2\n  end\n  subgraph PROJECT\n    direction TB\n    Project1((Project1))\n    Project1 --&gt; Assembly1\n    Project1 --&gt; Assembly2\n  end\n  subgraph ASSEMBLY\n    direction TB\n    Assembly1((Assembly1))\n    Assembly2((Assembly2))\n    Assembly1 --&gt; Namespace1\n    Assembly1 --&gt; Namespace2\n  end\n  subgraph NAMESPACE\n    direction TB\n    Namespace1((Namespace1))\n    Namespace2((Namespace2))\n    Namespace1 --&gt; Class1\n    Namespace1 --&gt; Class2\n  end\n  subgraph CLASS\n    direction TB\n    Class1((Class1))\n    Class2((Class2))\n    Class1 --&gt; Attribute1\n    Class1 --&gt; Method1\n  end</code></pre>"},{"location":"General%20Knowledge/Focas/#sample-project-setup","title":"Sample Project Setup","text":""},{"location":"General%20Knowledge/Focas/#project-directory-structure","title":"Project Directory Structure","text":"<pre><code>FanucFocas                      # The project root (i guess its a directory)\n    properties/                 # This directory may contain project-specific properties or settings files\n    references/                 # This directory may contain references to external libraries or dependencies, dll, etc\n    App.config/                 # This file is a configuration file for the application. It may contain settings such as connection strings, application-specific configurations, or environment variables.\n    fwlib32.cs/                 # This file represents the Focas library for CNC/PMC Data Window Library for FOCAS1/Ethernet. It contains the necessary classes and functions for interacting with \n                                # Focas enabled CNC machines.\n    packages.config/            # This file is used in older versions of .NET Framework projects to manage NuGet package references. It specifies the packages and their versions used in the project.\n    Program.cs                  # This file is the entry point of the application. It contains the main code that is executed when the application starts.\n</code></pre>"},{"location":"General%20Knowledge/Focas/#working-with-namespaces-and-external-libraries-in-c","title":"Working with Namespaces and External Libraries in C","text":""},{"location":"General%20Knowledge/Focas/#introduction_2","title":"Introduction","text":"<p>In C#, namespaces are used to organize and group related classes, structures, and other types. They provide a way to avoid naming conflicts and improve code organization. When working with external libraries, such as the Focas library in your project, namespaces play a crucial role in referencing and accessing the library's classes and structures.</p>"},{"location":"General%20Knowledge/Focas/#namespaces-in-c","title":"Namespaces in C","text":"<ul> <li>Namespaces are used to logically organize and group related code elements.</li> <li>They provide a hierarchical structure and help in avoiding naming conflicts.</li> <li>Namespaces improve code readability and maintainability.</li> </ul>"},{"location":"General%20Knowledge/Focas/#using-statements-and-namespaces","title":"Using Statements and Namespaces","text":"<ul> <li>To use classes and structures from a namespace, you need to include a using statement at the top of your file.</li> <li>The using statement allows you to access the classes and structures directly without specifying the fully qualified names.</li> </ul>"},{"location":"General%20Knowledge/Focas/#syntax","title":"Syntax:","text":"<pre><code>using NamespaceName;\n</code></pre>"},{"location":"General%20Knowledge/Focas/#example","title":"Example:","text":"<pre><code>using System;\nusing MyLibrary;\n</code></pre> <ul> <li>In the example above, <code>System</code> and <code>MyLibrary</code> are namespaces that contain the desired classes and structures.</li> </ul>"},{"location":"General%20Knowledge/Focas/#including-external-libraries-and-using-statements","title":"Including External Libraries and Using Statements","text":"<ul> <li>When working with external libraries, you need to include the library's files in your project.</li> <li>The files containing the classes and structures for the library should be located in a specific directory within your project.</li> <li>To access the library's classes and structures, you need to specify the appropriate using statement with the library's namespace.</li> </ul>"},{"location":"General%20Knowledge/Focas/#example_1","title":"Example:","text":"<p><pre><code>using FocasLibrary;\n</code></pre> - In this example, <code>FocasLibrary</code> is the namespace where the classes and structures from the Focas library are defined. - The using statement allows you to access those classes and structures directly in your code.</p>"},{"location":"General%20Knowledge/Focas/#the-fwlib32cs-file-and-global-namespace","title":"The fwlib32.cs File and Global Namespace","text":"<ul> <li>In the provided fwlib32.cs file (as shown in the project directory), the namespace is not explicitly defined (you can open the file and check it out).    </li> <li>However, when you include the fwlib32.cs file in your project and build it, the classes and structures in fwlib32.cs are treated as part of the global namespace.</li> <li>The global namespace includes all code elements that are not explicitly placed within a namespace.</li> <li>This means that you can directly reference the classes and structures from fwlib32.cs without the need for a using statement.</li> </ul>"},{"location":"General%20Knowledge/Focas/#adding-the-fwlibcs-library-to-a-visual-studio-project","title":"Adding the <code>fwlib.cs</code> Library to a Visual Studio Project","text":"<p>The following steps outline how to add the <code>fwlib.cs</code> library file to your current working project in Visual Studio. The <code>fwlib.cs</code> file contains the library code that you want to include in your project.</p>"},{"location":"General%20Knowledge/Focas/#steps","title":"Steps","text":"<ol> <li> <p>Open your project in Visual Studio.</p> </li> <li> <p>In the Solution Explorer, locate your project folder.</p> </li> <li> <p>Right-click on your project folder to open the context menu.</p> </li> <li> <p>From the context menu, select \"Add\" and then choose \"Existing Item.\" This action opens the file selection dialog.</p> </li> <li> <p>In the file selection dialog, navigate to the location where the <code>fwlib.cs</code> file is located on your computer.</p> </li> <li> <p>Select the <code>fwlib.cs</code> file.</p> </li> <li> <p>Click the \"Add\" button. This action adds the <code>fwlib.cs</code> file to your project.</p> </li> </ol> <p>The following figure shows how to add the library file in visual studio</p> <p></p>"},{"location":"General%20Knowledge/Focas/#purpose","title":"Purpose","text":"<p>Adding the <code>fwlib.cs</code> library file to your Visual Studio project is necessary to include the library's code in your project. By doing so, the compiler recognizes the library and its contents, enabling you to utilize its functionality in your code.</p>"},{"location":"General%20Knowledge/Focas/#special-notes-for-focas-api","title":"Special Notes for FOCAS API:","text":""},{"location":"General%20Knowledge/Focas/#adding-the-fwdll-files","title":"Adding the <code>fw*.dll</code> files","text":"<p>DLL stands for Dynamic Link Library. It is a type of file that contains code and data that can be used by multiple programs at the same time. DLL files are often used to provide common functionality, such as printing, graphics display, and network communication.</p> <p>DLL files are loaded into memory when a program needs them, and they are unloaded when the program is finished. This allows multiple programs to share the same DLL files without having to duplicate them in memory. This can save disk space and improve performance.</p> <p>DLL files are essential for the operation of many Windows programs. However, they can sometimes cause problems, such as missing DLL errors. These errors can occur when a DLL file is corrupted or missing, or when a program is trying to use a DLL file that is not compatible with it.</p> <p>Here are some examples of DLL files:</p> <ul> <li> <p>Comdlg32.dll: This DLL file provides common dialog box related functions, such as Open, Save, and Print dialog boxes.</p> </li> <li> <p>User32.dll: This DLL file provides functions for interacting with the Windows user interface, such as creating and managing windows, displaying messages, and handling user input.</p> </li> <li> <p>Gdi32.dll: This DLL file provides functions for graphics display, such as drawing shapes, text, and images.</p> </li> <li> <p>Ws2_32.dll: This DLL file provides functions for network communication, such as sending and receiving data over the Internet.</p> </li> </ul> <p>The functions for communicating with the fanuc based machines using focas is possible through the focas library, developed in c/c++ by fanuc. In our current program we are using a c sharp program which will act as a wrapper to the c/c++ library given by fanuc. In order to do this we have to follow two steps:</p> <ul> <li> <p>Including all dll files in <code>C:\\Windows\\SysWOW64</code> folder.</p> </li> <li> <p>Including the <code>fwlib.cs</code> file as shown previously.</p> </li> </ul>"},{"location":"General%20Knowledge/Focas/#steps_1","title":"Steps","text":"<ol> <li> <p>Download all the dll files from the following link: Fanuc Focas Dll Files</p> </li> <li> <p>Include all dll files in <code>C:\\Windows\\SysWOW64</code> folder (as shown in figure below).</p> </li> </ol> <p>The following figure shows the dll files added to the SysWOW64 folder:</p> <p></p>"},{"location":"General%20Knowledge/Focas/#creation-of-net-framework-application","title":"Creation of .Net Framework Application","text":"<p>Make sure that when you create a new project in visual studio you open a console application of type <code>.NetFramework</code> , if in case you choose .Net core you wont be able to see the.Net 4.7.2 framework (as the focas library is currently not working in core or other newer versions).</p> <p>The following figure shows creation of console application:</p> <p></p>"},{"location":"General%20Knowledge/Focas/#programs-to-demonstrate-focas-api","title":"Programs to Demonstrate Focas API","text":""},{"location":"General%20Knowledge/Focas/#code-sample-1","title":"CODE SAMPLE 1","text":""},{"location":"General%20Knowledge/Focas/#code","title":"CODE","text":"<p>Here is a sample c# code to get the machine state using fanuc focas api</p> <pre><code>    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Threading.Tasks;\n\n    namespace FanucFocas\n    {\n        class Program\n        {\n            static ushort _handle = 0;\n            static short _ret = 0;\n            static void Main(string[] args)\n            {\n                Console.WriteLine(\"Starting\");\n\n                _ret = Focas1.cnc_allclibhndl3(\"172.18.30.147\", 8193, 6, out _handle);\n\n                if (_ret != Focas1.EW_OK)\n                {\n                    Console.WriteLine(\"Cannot Connect\");\n                    Console.Read();\n                }\n                else {\n                    Console.WriteLine($\"Our Focas Handle is {_handle}\");\n\n                    string mode = GetMode();\n                    Console.WriteLine($\"\\n\\nMode is {mode}\");\n\n                    Console.Read();\n                }\n\n                Focas1.cnc_freelibhndl(_handle);\n            }\n\n            public static string GetMode() { \n                if (_handle ==0)\n                {\n                    Console.WriteLine(\"Get a handle\");\n                    return \"\";\n                }\n\n                Focas1.ODBST mode = new Focas1.ODBST();\n\n                _ret = Focas1.cnc_statinfo(_handle, mode);\n\n                if (_ret != 0) {\n                    Console.WriteLine(\"Error: Cannot obtain mode data\");\n                    return \"\";\n                }\n                return $\"Mode is {mode.aut}\";\n\n            }\n        }\n    }\n</code></pre>"},{"location":"General%20Knowledge/Focas/#explanation","title":"Explanation:","text":"<p>The given C# code demonstrates the usage of the Fanuc Focas API to connect to a Fanuc CNC system and retrieve the operating mode information. Let's go through the code step by step:</p> <ol> <li> <p>The code begins with the necessary using statements to import the required namespaces for the program.</p> </li> <li> <p>The FanucFocas namespace is defined to encapsulate the code.</p> </li> <li> <p>Within the FanucFocas namespace, the Program class is defined.</p> </li> <li> <p>The program declares some static variables: _handle of type ushort (unsigned short) to store the handle for the Focas connection, and _ret of type short to store the return values of Focas API functions.</p> </li> <li> <p>The Main method is the entry point of the program. It starts by printing \"Starting\" to the console.</p> </li> <li> <p>The Focas API function Focas1.cnc_allclibhndl3 is called to establish a connection with the Fanuc CNC system. The method takes the IP address (in this case, \"172.18.30.147\"), port number (8193), Focas version (6), and an out parameter _handle to receive the handle for the connection. The return value _ret is checked to determine if the connection was successful.</p> </li> <li> <p>If the connection fails, the program prints \"Cannot Connect\" to the console and waits for user input before exiting.</p> </li> <li> <p>If the connection succeeds, the program prints the obtained _handle value to the console.</p> </li> <li> <p>The GetMode method is called to retrieve the operating mode information from the CNC system.</p> </li> <li> <p>Inside the GetMode method, it first checks if a valid handle _handle exists. If not, it prints \"Get a handle\" to the console and returns an empty string.</p> </li> <li> <p>It declares an instance of the ODBST struct (a structure provided by the Focas API) named mode.</p> </li> <li> <p>The Focas API function Focas1.cnc_statinfo is called to obtain the mode data using the handle _handle and the mode variable. The return value _ret is checked to ensure successful data retrieval.</p> </li> <li> <p>If the data retrieval is successful, it returns a string indicating the mode by accessing the aut property of the mode struct.</p> </li> <li> <p>Finally, the obtained mode information is printed to the console.</p> </li> <li> <p>The program waits for user input before exiting.</p> </li> <li> <p>After reading the user input, the program calls Focas1.cnc_freelibhndl to free the allocated Focas library handle.</p> </li> </ol> <p>Overall, this code demonstrates the basic usage of the Fanuc Focas API in C# to establish a connection with a Fanuc CNC system and retrieve the operating mode information.</p>"},{"location":"General%20Knowledge/Focas/#code-sample-2","title":"CODE SAMPLE 2","text":""},{"location":"General%20Knowledge/Focas/#code_1","title":"Code","text":"<pre><code>    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Threading.Tasks;\n\n    namespace FanucFocas\n    {\n        class Program\n        {\n            static ushort _handle = 0;\n            static short _ret = 0;\n            static void Main(string[] args)\n            {\n                Console.WriteLine(\"Starting\");\n\n                _ret = Focas1.cnc_allclibhndl3(\"172.18.30.147\", 8193, 6, out _handle);\n\n                if (_ret != Focas1.EW_OK)\n                {\n                    Console.WriteLine(\"Cannot Connect\");\n                    Console.Read();\n                }\n                else {\n                    Console.WriteLine($\"Our Focas Handle is {_handle}\");\n\n                    string mode = GetMode();\n                    Console.WriteLine($\"\\n\\nMode is {mode}\");\n\n                    Console.Read();\n                }\n\n                Focas1.cnc_freelibhndl(_handle);\n            }\n\n            public static string GetMode() { \n            if (_handle == 0)\n            {\n                Console.WriteLine(\"Get a handle\");\n                return \"\";\n            }\n\n            Focas1.ODBST mode = new Focas1.ODBST();\n\n            _ret = Focas1.cnc_statinfo(_handle, mode);\n\n            if (_ret != 0)\n            {\n                Console.WriteLine(\"Error: Cannot obtain mode data\");\n                return \"\";\n            }\n\n            switch (mode.aut)\n            {\n                case 0: return \"MDI\";\n                case 1: return \"MEM\";\n                case 3: return \"EDIT\";\n                case 4: return \"MPG\";\n                case 5: return \"JOG\";\n                case 6: return \"Teach in JOG\";\n                case 7: return \"Teach in HND\";\n                case 8: return \"INC\";\n                case 9: return \"REF\";\n                case 10: return \"RMT\";\n                default: return \"UNAVAILABLE\";\n            }\n\n            }\n        }\n    }\n</code></pre>"},{"location":"General%20Knowledge/Focas/#explanation_1","title":"Explanation","text":"<ol> <li> <p>The code begins with the necessary using statements to import the required namespaces for the program.</p> </li> <li> <p>The <code>FanucFocas</code> namespace is defined to encapsulate the code.</p> </li> <li> <p>Within the <code>FanucFocas</code> namespace, the <code>Program</code> class is defined.</p> </li> <li> <p>The program declares some static variables: <code>_handle</code> of type <code>ushort</code> (unsigned short) to store the handle for the Focas connection, and <code>_ret</code> of type <code>short</code> to store the return values of Focas API functions.</p> </li> <li> <p>The <code>Main</code> method is the entry point of the program. It starts by printing \"Starting\" to the console.</p> </li> <li> <p>The Focas API function <code>Focas1.cnc_allclibhndl3</code> is called to establish a connection with the Fanuc CNC system. The method takes the IP address (in this case, \"172.18.30.147\"), port number (8193), Focas version (6), and an <code>out</code> parameter <code>_handle</code> to receive the handle for the connection. The return value <code>_ret</code> is checked to determine if the connection was successful.</p> </li> <li> <p>If the connection fails, the program prints \"Cannot Connect\" to the console and waits for user input before exiting.</p> </li> <li> <p>If the connection succeeds, the program prints the obtained <code>_handle</code> value to the console.</p> </li> <li> <p>The <code>GetMode</code> method is called to retrieve the operating mode information from the CNC system.</p> </li> <li> <p>Inside the <code>GetMode</code> method, it first checks if a valid handle <code>_handle</code> exists. If not, it prints \"Get a handle\" to the console and returns an empty string.</p> </li> <li> <p>It declares an instance of the <code>ODBST</code> struct (a structure provided by the Focas API) named <code>mode</code>.</p> </li> <li> <p>The Focas API function <code>Focas1.cnc_statinfo</code> is called to obtain the mode data using the handle <code>_handle</code> and the <code>mode</code> variable. The return value <code>_ret</code> is checked to ensure successful data retrieval.</p> </li> <li> <p>If the data retrieval is successful, a <code>switch</code> statement is used to map the <code>mode.aut</code> value to the corresponding operating mode string.</p> </li> <li> <p>The operating mode string is returned.</p> </li> <li> <p>Finally, the obtained mode information is printed to the console.</p> </li> <li> <p>The program waits for user input before exiting.</p> </li> <li> <p>After reading the user input, the program calls <code>Focas1.cnc_freelibhndl</code> to free the allocated Focas library handle.</p> </li> </ol>"},{"location":"General%20Knowledge/Focas/#mode","title":"MODE","text":"<p>The different modes and their corresponding full forms are as follows:</p> <ol> <li> <p><code>MDI</code> (Manual Data Input): In this mode, the operator has the ability to input instructions and programs directly into the CNC system manually. While it is not necessary for the operation to be limited to a single line, sometimes we require a simple operation like tool change, which can be accomplished in MDI mode. To achieve this, the machine must be set to MDI mode, and then, using the Human Machine Interface (HMI), the operator can manually enter the G Code that needs to be executed. Once the code is entered, the operator can initiate the cycle start by pressing the corresponding button. An example of such a process can be seen in the video provided. For instance, the code <code>T01 M06</code> would be used to change to tool number 1. Video .</p> </li> <li> <p><code>MEM</code> (Memory): In this mode, the CNC system runs programs stored in its memory. This mode is known as the automatic mode, where the CNC machine loads the entire G Code file into its memory and executes it automatically, without any manual intervention. In this mode, the machine follows the instructions provided in the G Code file from start to finish. The entire code is executed sequentially, allowing for a fully automated operation. The machine takes care of executing each command in the G Code file without requiring any further input or interaction from the operator.</p> </li> <li> <p><code>EDIT</code> (Edit): At times, it becomes necessary to make changes to an existing CNC program, such as adjusting the feed rate or spindle speed. In such cases, the Edit mode provides the operator with the capability to modify or create CNC programs using an editing interface. This mode offers a user-friendly interface specifically designed for editing purposes. The operator can access the program and make the desired modifications, such as changing parameters, adding or removing commands, or adjusting settings related to feed rate and spindle speed. The Edit mode empowers the operator to fine-tune CNC programs to meet specific requirements, ensuring flexibility and customization in the machining process. video.</p> </li> <li> <p><code>MPG</code> (Manual Pulse Generator): MPG mode is a specific operating mode in CNC systems that allows the operator to manually control the machine's movement using a manual pulse generator device. The manual pulse generator is a handheld device equipped with a rotary knob or wheels that provide precise control over machine motion. In MPG mode, the operator can manually generate pulses or increments of movement using the manual pulse generator. Each pulse corresponds to a specific movement increment, such as a defined distance or angular rotation. By rotating the knob or wheels, the operator can control the speed and direction of the machine tool's movement. By providing precise control over machine movement, MPG mode enhances operator interaction and enables fine adjustments or manual operations that require a high degree of accuracy. It offers a versatile and hands-on approach to machine control, complementing other modes and functionalities provided by CNC systems. Video. MPG mode is particularly useful in various scenarios, including:</p> <ul> <li> <p>Fine Positioning: MPG mode allows operators to make small, precise adjustments to position the machine tool accurately. It provides a tactile and intuitive control mechanism, enabling fine-tuning and alignment of workpieces or tooling.</p> </li> <li> <p>Manual Operation: During setup, testing, or maintenance tasks, operators may need to manually control the machine tool for specific operations. MPG mode offers a convenient way to perform manual movements, such as tool alignment, verifying clearances, or inspecting workpiece details.</p> </li> <li> <p>Manual Machining: In certain situations, manual machining or manual intervention is required for complex or delicate operations. MPG mode allows the operator to manually guide the machine tool along the desired path, ensuring precise machining in real-time.</p> </li> <li> <p>Jogging: MPG mode can also be used for jogging the machine tool, allowing the operator to move the machine incrementally in different directions. This feature is useful for step-by-step setup, alignment, or manual machining tasks.</p> </li> </ul> </li> <li> <p><code>JOG</code> (Jogging): Jog mode allows the operator to manually move the machine tool in different directions incrementally. Jogging (as an operation, not as a mode) is an essential functionality in CNC (Computer Numerical Control) systems that allows operators to manually move the machine tool in a controlled manner. In jogging mode, the operator can incrementally move the machine tool in different directions, providing flexibility and precision in positioning and setup tasks. Jogging is widely used in various applications, including CNC machining, milling, turning, routing, and more. It offers operators a hands-on approach to position and align the machine tool precisely. By enabling manual control, jogging enhances the operator's ability to perform fine adjustments, verify positions, and ensure optimal machine performance. Here's more information about jogging:</p> <ul> <li> <p>Incremental Movements: Jogging enables the operator to move the machine tool incrementally in small steps. The step size can be predefined or adjustable, allowing for fine-tuning of machine positions. The operator typically controls the movement using dedicated buttons, a pendant, or a control panel.</p> </li> <li> <p>Directional Control: Jogging allows movement in multiple directions, such as X, Y, and Z axes. The operator can move the machine tool along each axis independently or simultaneously, depending on the machine's configuration and capabilities.</p> </li> <li> <p>Speed Control: Jogging mode often provides speed control options. Operators can adjust the speed of movement to match the specific requirements of the task. This feature allows for precise positioning and control over the machine tool's motion.</p> </li> <li> <p>Manual Alignment: Jogging is commonly used for aligning tools or workpieces. By manually moving the machine tool, operators can align the cutting tool with the desired position on the workpiece, ensuring accurate machining.</p> </li> <li> <p>Setup and Inspection: Jogging is valuable during setup and inspection tasks. Operators can jog the machine tool to specific positions, allowing them to verify clearances, check dimensions, or align fixtures accurately. It helps in verifying that the workpiece and tooling are correctly positioned before starting automated machining operations.</p> </li> <li> <p>User-Friendly Interface: CNC systems often provide user-friendly interfaces for jogging, including dedicated jog wheels, control pendants, or software-based jog controls. These interfaces enhance the operator's experience by providing intuitive controls and real-time feedback on the machine tool's position.</p> </li> <li> <p>The same jogginf functionality can be achieved</p> </li> </ul> </li> <li> <p><code>Teach in JOG</code>: This mode is similar to the JOG mode but specifically designed for teaching the machine by manually moving it through the desired motions.</p> </li> <li> <p><code>Teach in HND</code> (Teach in Handle): This mode enables the operator to control the machine's movement using a manual control handle.</p> </li> <li> <p><code>INC</code> (Incremental): In this mode, the machine tool moves incrementally based on defined increments or distances.</p> </li> <li> <p><code>REF</code> (Reference): The Reference mode allows the machine tool to perform a homing or reference operation.</p> </li> <li> <p><code>RMT</code> (Remote): Remote mode enables the CNC system to receive commands and instructions from an external device or computer.</p> </li> <li> <p><code>UNAVAILABLE</code>: This is the default case when the mode information is unavailable or cannot be retrieved from the CNC system.</p> </li> </ol> <p>Please note that the full forms provided here are general explanations and may vary depending on the specific CNC system or context.</p>"},{"location":"General%20Knowledge/Focas/#code-sample-3","title":"CODE SAMPLE 3","text":""},{"location":"General%20Knowledge/Focas/#code_2","title":"Code","text":"<pre><code>    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Threading.Tasks;\n\n    namespace FanucFocas\n    {\n        class Program\n        {\n            static ushort _handle = 0;\n            static short _ret = 0;\n            static void Main(string[] args)\n            {\n                Console.WriteLine(\"Starting\");\n\n                _ret = Focas1.cnc_allclibhndl3(\"172.18.30.147\", 8193, 6, out _handle);\n\n                if (_ret != Focas1.EW_OK)\n                {\n                    Console.WriteLine(\"Cannot Connect\");\n                    Console.Read();\n                }\n                else {\n                    Console.WriteLine($\"Our Focas Handle is {_handle}\");\n\n                    string mode = GetMode();\n                    Console.WriteLine($\"\\n\\nMode is {mode}\");\n\n                    Console.Read();\n                }\n\n                Focas1.cnc_freelibhndl(_handle);\n            }\n\n            public static string GetMode() { \n            if (_handle == 0)\n            {\n                Console.WriteLine(\"Get a handle\");\n                return \"\";\n            }\n\n            Focas1.ODBST mode = new Focas1.ODBST();\n\n            _ret = Focas1.cnc_statinfo(_handle, mode);\n\n            if (_ret != 0)\n            {\n                Console.WriteLine(\"Error: Cannot obtain mode data\");\n                return \"\";\n            }\n\n            switch (mode.aut)\n            {\n                case 0: return \"MDI\";\n                case 1: return \"MEM\";\n                case 3: return \"EDIT\";\n                case 4: return \"MPG\";\n                case 5: return \"JOG\";\n                case 6: return \"Teach in JOG\";\n                case 7: return \"Teach in HND\";\n                case 8: return \"INC\";\n                case 9: return \"REF\";\n                case 10: return \"RMT\";\n                default: return \"UNAVAILABLE\";\n            }\n\n            }\n\n            public static string GetStatus()\n            {\n                if (_handle == 0)\n                {\n                    Console.WriteLine(\"Get a handle\");\n                    return \"\";\n                }\n\n                Focas1.ODBST status = new Focas1.ODBST();\n                _ret = Focas1.cnc_statinfo(_handle, status);\n\n                if (_ret != 0)\n                {\n                    Console.WriteLine(\"Error: Cannot obtain status data\");\n                    return \"\";\n                }\n\n                switch (status.run)\n                {\n                    case 0: return \"*****\";\n                    case 1: return \"STOP\";\n                    case 2: return \"HOLD\";\n                    case 3: return \"STRT\";\n                    case 4: return \"MSTR\";\n                    default: return \"UNAVAILABLE\";\n                }\n            }\n\n        }\n    }\n</code></pre>"},{"location":"General%20Knowledge/Focas/#explanation_2","title":"EXPLANATION","text":"<p>The given code is a C# program that uses the Fanuc Focas API to connect to a Fanuc CNC system, retrieve the operating mode information, and obtain the status of the CNC machine. Here's a breakdown of the code:</p> <ol> <li> <p>The code begins with the necessary using statements to import the required namespaces for the program.</p> </li> <li> <p>The FanucFocas namespace is defined to encapsulate the code.</p> </li> <li> <p>Within the FanucFocas namespace, the Program class is defined.</p> </li> <li> <p>The program declares some static variables: <code>_handle</code> of type <code>ushort</code> (unsigned short) to store the handle for the Focas connection, and <code>_ret</code> of type <code>short</code> to store the return values of Focas API functions.</p> </li> <li> <p>The <code>Main</code> method is the entry point of the program. It starts by printing \"Starting\" to the console.</p> </li> <li> <p>The Focas API function <code>Focas1.cnc_allclibhndl3</code> is called to establish a connection with the Fanuc CNC system. The method takes the IP address (in this case, \"172.18.30.147\"), port number (8193), Focas version (6), and an <code>out</code> parameter <code>_handle</code> to receive the handle for the connection. The return value <code>_ret</code> is checked to determine if the connection was successful.</p> </li> <li> <p>If the connection fails, the program prints \"Cannot Connect\" to the console and waits for user input before exiting.</p> </li> <li> <p>If the connection succeeds, the program prints the obtained <code>_handle</code> value to the console.</p> </li> <li> <p>The <code>GetMode</code> method is called to retrieve the operating mode information from the CNC system.</p> </li> <li> <p>Inside the <code>GetMode</code> method, it first checks if a valid handle <code>_handle</code> exists. If not, it prints \"Get a handle\" to the console and returns an empty string.</p> </li> <li> <p>It declares an instance of the <code>ODBST</code> struct (a structure provided by the Focas API) named <code>mode</code>.</p> </li> <li> <p>The Focas API function <code>Focas1.cnc_statinfo</code> is called to obtain the mode data using the handle <code>_handle</code> and the <code>mode</code> variable. The return value <code>_ret</code> is checked to ensure successful data retrieval.</p> </li> <li> <p>If the data retrieval is successful, a <code>switch</code> statement is used to map the <code>mode.aut</code> value to the corresponding operating mode string.</p> </li> <li> <p>The operating mode string is returned and printed to the console.</p> </li> <li> <p>The <code>GetStatus</code> method is also defined to retrieve the current status of the CNC machine.</p> </li> <li> <p>The <code>GetStatus</code> method is similar to <code>GetMode</code> and follows the same pattern of checking the handle, declaring an instance of the <code>ODBST</code> struct for status, calling <code>cnc_statinfo</code>, and using a <code>switch</code> statement to map the <code>status.run</code> value to the corresponding status string.</p> </li> <li> <p>Finally, the obtained status information is returned and printed to the console.</p> </li> <li> <p>The program waits for user input before exiting.</p> </li> </ol> <p>The <code>cnc_statinfo</code> function is part of the FANUC FOCAS library, which is used for CNC machine control. This function is used to retrieve the status information of the CNC machine.</p> <p>The <code>cnc_statinfo</code> function returns a structure that contains several fields, two of which are <code>.aut</code> and <code>.run</code>.</p> <ul> <li> <p><code>.aut</code> field: This field represents the automatic operation mode status. It has three possible values: 0 (MDI mode), 1 (MEM mode), and 2 (EDIT mode).</p> </li> <li> <p><code>.run</code> field: This field represents the running status of the CNC machine in automatic mode. It has five possible values:</p> </li> <li> <p>0: This value is represented as \"*\" in the code snippet we've provided. It likely represents a default or uninitialized state.</p> </li> <li>1: This value is represented as \"STOP\" in the code snippet, indicating that the CNC machine is in a stopped state.</li> <li>2: This value is represented as \"HOLD\" in the code snippet, indicating that the CNC machine is in a hold or paused state. This happens when the <code>cycle stop</code> button is pressed in the machine</li> <li>3: This value is represented as \"STRT\" in the code snippet, indicating that the CNC machine is in a start or running state.</li> <li>4: This value is represented as \"MSTR\" in the code snippet, indicating that the CNC machine is in a master or controlling state.</li> </ul> <p>The \"default\" case in the switch statement is used to handle any other values that the <code>.run</code> field might have. In this case, it returns \"UNAVAILABLE\", indicating that the running status of the CNC machine is not available or not recognized.</p>"},{"location":"General%20Knowledge/Focas/#sample-sequence-of-machine-state","title":"SAMPLE SEQUENCE OF MACHINE STATE","text":"<p>The following table shows a sample sequence of machine states and their corresponding execution mode and running status</p> S.No Actual Machine State Execution Mode (From Focas) Execution Mode (Mapped Value) Running Status (From Focas) Running Status (Mapped Value) 1. Machine is in auto Mode, a cycle has been started and it's running 1 MEM 3 STRT 2. Machine is in auto Mode, a cycle has ended from previous state 1 MEM 0 *** 3. Auto Mode, cycle start &amp; Running 1 MEM 3 STRT 4. Auto Mode, cycle suspend in middle (pressed the cycle stop button in fanuc controller) 1 MEM 2 HOLD 5. Auto Mode, cycle resume after suspend 1 MEM 3 STRT 6. Auto Mode, cycle suspend in middle 1 MEM 2 HOLD 7. Auto Mode, cycle cancelled (cancelled after suspend, cycle did not get over, by pressing reset button) 1 MEM 0 *** 8. Auto Mode, cycle stop (nothing going), emergency button 1 MEM 0 *** 9. Emergency button released (from previous step) 1 MEM 0 *** 10. Auto Mode, cycle start, emergency button pressed 1 MEM 0 *** 11. Emergency button released (from previous step) 1 MEM 0 *** 12. MDI Mode 0 MDI 1 STOP 13. EDIT Mode 3 EDIT 0 *** 14. MPG Mode 4 MPG (Hand Wheel) 0 *** 15. JOG Mode 5 JOG 0 *** 16. REF Mode 9 REF 0 ***"},{"location":"General%20Knowledge/Focas/#code-sample-4","title":"CODE SAMPLE 4","text":""},{"location":"General%20Knowledge/Focas/#code_3","title":"Code","text":"<pre><code>    using System;\n    using System.Threading;\n\n    namespace FanucFocas\n    {\n        class Program\n        {\n            static ushort _handle = 0;\n            static short _ret = 0;\n\n            static void Main(string[] args)\n            {\n                Console.WriteLine(\"Starting\");\n\n                _ret = Focas1.cnc_allclibhndl3(\"172.18.30.147\", 8193, 6, out _handle);\n\n                if (_ret != Focas1.EW_OK)\n                {\n                    Console.WriteLine(\"Cannot Connect\");\n                    Console.Read();\n                    return;\n                }\n\n                Console.WriteLine($\"Our Focas Handle is {_handle}\");\n\n                // Create a loop to continuously print machine mode and status every 2 seconds\n                while (true)\n                {\n                    Console.WriteLine(\"=====================\");\n\n                    string mode = GetMode();\n                    Console.WriteLine($\"Mode is {mode}\");\n\n                    string status = GetStatus();\n                    Console.WriteLine($\"Status is {status}\");\n\n                    Console.WriteLine(\"=====================\");\n\n                    // Wait for 2 seconds before the next iteration\n                    Thread.Sleep(2000);\n                }\n\n                Focas1.cnc_freelibhndl(_handle);\n            }\n\n            public static string GetMode()\n            {\n                if (_handle == 0)\n                {\n                    Console.WriteLine(\"Get a handle\");\n                    return \"\";\n                }\n\n                Focas1.ODBST mode = new Focas1.ODBST();\n                _ret = Focas1.cnc_statinfo(_handle, mode);\n\n                if (_ret != 0)\n                {\n                    Console.WriteLine(\"Error: Cannot obtain mode data\");\n                    return \"\";\n                }\n\n                switch (mode.aut)\n                {\n                    case 0: return \"MDI\";\n                    case 1: return \"MEM\";\n                    case 3: return \"EDIT\";\n                    case 4: return \"MPG\";\n                    case 5: return \"JOG\";\n                    case 6: return \"Teach in JOG\";\n                    case 7: return \"Teach in HND\";\n                    case 8: return \"INC\";\n                    case 9: return \"REF\";\n                    case 10: return \"RMT\";\n                    default: return \"UNAVAILABLE\";\n                }\n            }\n\n            public static string GetStatus()\n            {\n                if (_handle == 0)\n                {\n                    Console.WriteLine(\"Get a handle\");\n                    return \"\";\n                }\n\n                Focas1.ODBST status = new Focas1.ODBST();\n                _ret = Focas1.cnc_statinfo(_handle, status);\n\n                if (_ret != 0)\n                {\n                    Console.WriteLine(\"Error: Cannot obtain status data\");\n                    return \"\";\n                }\n\n                switch (status.run)\n                {\n                    case 0: return \"*****\";\n                    case 1: return \"STOP\";\n                    case 2: return \"HOLD\";\n                    case 3: return \"STRT\";\n                    case 4: return \"MSTR\";\n                    default: return \"UNAVAILABLE\";\n                }\n            }\n        }\n    }\n</code></pre>"},{"location":"General%20Knowledge/Focas/#explanation_3","title":"EXPLANATION","text":"<p>The provided code is a C# program that uses the Fanuc Focas API to establish a connection with a Fanuc CNC system, retrieve the machine mode and operational status information, and continuously display them every 2 seconds. It utilizes the <code>GetMode()</code> and <code>GetStatus()</code> methods to retrieve the corresponding information.</p> <p>Line-by-Line Explanation:</p> <p><pre><code>using System;\nusing System.Threading;\n</code></pre> The necessary namespaces are imported for the program.</p> <p><pre><code>namespace FanucFocas\n{\n    class Program\n    {\n        static ushort _handle = 0;\n        static short _ret = 0;\n</code></pre> The code defines the <code>FanucFocas</code> namespace and the <code>Program</code> class. It declares two static variables: <code>_handle</code> of type <code>ushort</code> (unsigned short) to store the Focas connection handle, and <code>_ret</code> of type <code>short</code> to store the return values of Focas API functions.</p> <p><pre><code>        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Starting\");\n\n            _ret = Focas1.cnc_allclibhndl3(\"172.18.30.147\", 8193, 6, out _handle);\n\n            if (_ret != Focas1.EW_OK)\n            {\n                Console.WriteLine(\"Cannot Connect\");\n                Console.Read();\n                return;\n            }\n</code></pre> The <code>Main</code> method is the entry point of the program. It starts by printing \"Starting\" to the console. Then, it attempts to establish a connection with the Fanuc CNC system using the <code>Focas1.cnc_allclibhndl3</code> API function, providing the IP address, port number, Focas version, and the <code>_handle</code> variable to receive the handle. If the connection fails, an error message is displayed and the program terminates.</p> <p><pre><code>            Console.WriteLine($\"Our Focas Handle is {_handle}\");\n</code></pre> If the connection succeeds, the obtained <code>_handle</code> value is printed to the console.</p> <p><pre><code>            while (true)\n            {\n                Console.WriteLine(\"=====================\");\n\n                string mode = GetMode();\n                Console.WriteLine($\"Mode is {mode}\");\n\n                string status = GetStatus();\n                Console.WriteLine($\"Status is {status}\");\n\n                Console.WriteLine(\"=====================\");\n\n                Thread.Sleep(2000);\n            }\n</code></pre> A <code>while</code> loop is created to continuously retrieve and display the machine mode and operational status every 2 seconds. Inside the loop, the mode and status information are obtained using the <code>GetMode()</code> and <code>GetStatus()</code> methods respectively. The information is then printed to the console with appropriate labels. The loop is paused for 2 seconds using <code>Thread.Sleep()</code> before the next iteration.</p> <p><pre><code>            Focas1.cnc_freelibhndl(_handle);\n        }\n</code></pre> Finally, after exiting the loop, the <code>Focas1.cnc_freelibhndl</code> API function is called to free the allocated Focas library handle.</p> <p><pre><code>        public static string GetMode()\n        {\n            // Mode retrieval logic\n        }\n</code></pre> The <code>GetMode()</code> method is defined to retrieve the machine mode information from the CNC system. It returns a string representation of the mode.</p> <p><pre><code>        public static string GetStatus()\n        {\n            // Status retrieval logic\n        }\n    }\n}\n</code></pre> Similarly, the <code>GetStatus()</code> method is defined to retrieve the operational status of the CNC machine. It returns a string representation of the status.</p> <p>The remaining part of the code contains the closing braces to close the <code>Program</code> class and <code>FanucFocas</code> namespace.</p> <p>Overall, the program establishes a connection with</p> <p>the Fanuc CNC system, retrieves and continuously displays the machine mode and operational status every 2 seconds until terminated.</p>"},{"location":"General%20Knowledge/Focas/#code-sample-5","title":"CODE SAMPLE 5","text":""},{"location":"General%20Knowledge/Focas/#code_4","title":"Code","text":"<pre><code>using System;\nusing System.Threading;\n\nnamespace FanucFocas\n{\n    class Program\n    {\n        static ushort _handle = 0;\n        static short _ret = 0;\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Starting\");\n\n            _ret = Focas1.cnc_allclibhndl3(\"172.18.30.147\", 8193, 6, out _handle);\n\n            if (_ret != Focas1.EW_OK)\n            {\n                Console.WriteLine(\"Cannot Connect\");\n                Console.Read();\n                return;\n            }\n\n            Console.WriteLine($\"Our Focas Handle is {_handle}\");\n\n            // Register the event handler for Ctrl+C or closing the terminal window\n            Console.CancelKeyPress += Console_CancelKeyPress;\n\n            try\n            {\n                // Create a loop to continuously print machine mode, status, and active program every 2 seconds\n                while (true)\n                {\n                    Console.WriteLine(\"=====================\");\n\n                    string mode = GetMode();\n                    Console.WriteLine($\"Mode is {mode}\");\n\n                    string status = GetStatus();\n                    Console.WriteLine($\"Status is {status}\");\n\n                    GetExecutionProgram();\n\n                    Console.WriteLine(\"=====================\");\n\n                    // Wait for 2 seconds before the next iteration\n                    Thread.Sleep(2000);\n                }\n            }\n            finally\n            {\n                // Free the Focas handle when the loop exits\n                Focas1.cnc_freelibhndl(_handle);\n            }\n        }\n\n        private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n        {\n            // Cancel the event to prevent termination\n            e.Cancel = true;\n\n            // Exit the program gracefully\n            Environment.Exit(0);\n        }\n\n        public static string GetMode()\n        {\n            if (_handle == 0)\n            {\n                Console.WriteLine(\"Get a handle\");\n                return \"\";\n            }\n\n            Focas1.ODBST mode = new Focas1.ODBST();\n            _ret = Focas1.cnc_statinfo(_handle, mode);\n\n            if (_ret != 0)\n            {\n                Console.WriteLine(\"Error: Cannot obtain mode data\");\n                return \"\";\n            }\n\n            switch (mode.aut)\n            {\n                case 0: return \"MDI\";\n                case 1: return \"MEM\";\n                case 3: return \"EDIT\";\n                case 4: return \"MPG\";\n                case 5: return \"JOG\";\n                case 6: return \"Teach in JOG\";\n                case 7: return \"Teach in HND\";\n                case 8: return \"INC\";\n                case 9: return \"REF\";\n                case 10: return \"RMT\";\n                default: return \"UNAVAILABLE\";\n            }\n        }\n\n        public static string GetStatus()\n        {\n            if (_handle == 0)\n            {\n                Console.WriteLine(\"Get a handle\");\n                return \"\";\n            }\n\n            Focas1.ODBST status = new Focas1.ODBST();\n            _ret = Focas1.cnc_statinfo(_handle, status);\n\n            if (_ret != 0)\n            {\n                Console.WriteLine(\"Error: Cannot obtain status data\");\n                return \"\";\n            }\n\n            switch (status.run)\n            {\n                case 0: return \"*****\";\n                case 1: return \"STOP\";\n                case 2: return \"HOLD\";\n                case 3: return \"STRT\";\n                case 4: return \"MSTR\";\n                default: return \"UNAVAILABLE\";\n            }\n        }\n\n        public static void GetExecutionProgram()\n        {\n            if (_handle == 0)\n            {\n                Console.WriteLine(\"Get a handle\");\n                return;\n            }\n\n            Focas1.ODBEXEPRG prg_info = new Focas1.ODBEXEPRG();\n\n            _ret = Focas1.cnc_exeprgname(_handle, prg_info);\n\n            if (_ret != 0)\n            {\n                Console.WriteLine(\"Error: Cannot obtain program data\");\n                return;\n            }\n            string programName = new string(prg_info.name).TrimEnd('\\0');\n\n            Console.WriteLine($\"Executing Program Name: {programName}\");\n        }\n    }\n}\n</code></pre>"},{"location":"General%20Knowledge/Focas/#explanation_4","title":"Explanation","text":"<p>The provided code is a C# program that interacts with a FANUC CNC machine using the Focas library. It connects to the CNC machine, retrieves information about the machine's mode, status, and active program, and continuously prints this information every 2 seconds.</p> <p>Let's go through the code step by step:</p> <p><pre><code>using System;\nusing System.Threading;\n</code></pre> The code includes necessary namespaces for the program.</p> <p><pre><code>namespace FanucFocas\n{\n    class Program\n    {\n        static ushort _handle = 0;\n        static short _ret = 0;\n</code></pre> The code defines a namespace (<code>FanucFocas</code>) and a class (<code>Program</code>). It also declares two static variables <code>_handle</code> (of type <code>ushort</code>) and <code>_ret</code> (of type <code>short</code>) to store the Focas handle and return value respectively.</p> <p><pre><code>        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Starting\");\n\n            _ret = Focas1.cnc_allclibhndl3(\"172.18.30.147\", 8193, 6, out _handle);\n\n            if (_ret != Focas1.EW_OK)\n            {\n                Console.WriteLine(\"Cannot Connect\");\n                Console.Read();\n                return;\n            }\n</code></pre> The <code>Main</code> method is the entry point of the program. It first prints \"Starting\" to the console. Then it calls the <code>cnc_allclibhndl3</code> function from the Focas library to establish a connection with the CNC machine using the specified IP address (\"172.18.30.147\"), port number (8193), and timeout (6 seconds). The Focas handle is stored in the <code>_handle</code> variable, and the return value is stored in the <code>_ret</code> variable.</p> <p>If the connection is unsuccessful (return value is not equal to <code>Focas1.EW_OK</code>), it prints \"Cannot Connect\" and waits for user input before exiting the program.</p> <p><pre><code>            Console.WriteLine($\"Our Focas Handle is {_handle}\");\n\n            // Register the event handler for Ctrl+C or closing the terminal window\n            Console.CancelKeyPress += Console_CancelKeyPress;\n\n            try\n            {\n                // Create a loop to continuously print machine mode, status, and active program every 2 seconds\n                while (true)\n                {\n                    Console.WriteLine(\"=====================\");\n\n                    string mode = GetMode();\n                    Console.WriteLine($\"Mode is {mode}\");\n\n                    string status = GetStatus();\n                    Console.WriteLine($\"Status is {status}\");\n\n                    GetExecutionProgram();\n\n                    Console.WriteLine(\"=====================\");\n\n                    // Wait for 2 seconds before the next iteration\n                    Thread.Sleep(2000);\n                }\n            }\n            finally\n            {\n                // Free the Focas handle when the loop exits\n                Focas1.cnc_freelibhndl(_handle);\n            }\n        }\n</code></pre> The program then prints the obtained Focas handle to the console. It registers the <code>Console_CancelKeyPress</code> method as an event handler for the Ctrl+C key press or closing the terminal window. This ensures that the program exits gracefully when these events occur.</p> <p>Inside the <code>try</code> block, the program enters a loop that continuously retrieves and prints information about the machine's mode, status, and active program every 2 seconds.</p> <p>The <code>GetMode()</code> method is called to retrieve the current machine mode, which is then printed to the console.</p> <p>The <code>GetStatus()</code> method is called to retrieve the current machine status, which is also printed to the console.</p> <p>The <code>GetExecutionProgram()</code> method is called to retrieve the name of the currently executing program on the machine, which is printed to the console.</p> <p>After printing the information, the program waits for</p> <p>2 seconds using <code>Thread.Sleep(2000)</code> before the next iteration of the loop.</p> <p>Finally, in the <code>finally</code> block, the Focas handle is released using the <code>cnc_freelibhndl</code> function to free up resources when the program exits.</p> <p><pre><code>        private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n        {\n            // Cancel the event to prevent termination\n            e.Cancel = true;\n\n            // Exit the program gracefully\n            Environment.Exit(0);\n        }\n</code></pre> The <code>Console_CancelKeyPress</code> method is an event handler that is triggered when the Ctrl+C key is pressed or the terminal window is closed. It cancels the event (<code>e.Cancel = true</code>) to prevent immediate termination of the program. Then it gracefully exits the program using <code>Environment.Exit(0)</code>.</p> <p><pre><code>        public static string GetMode()\n        {\n            if (_handle == 0)\n            {\n                Console.WriteLine(\"Get a handle\");\n                return \"\";\n            }\n\n            Focas1.ODBST mode = new Focas1.ODBST();\n            _ret = Focas1.cnc_statinfo(_handle, mode);\n\n            if (_ret != 0)\n            {\n                Console.WriteLine(\"Error: Cannot obtain mode data\");\n                return \"\";\n            }\n\n            switch (mode.aut)\n            {\n                case 0: return \"MDI\";\n                case 1: return \"MEM\";\n                case 3: return \"EDIT\";\n                case 4: return \"MPG\";\n                case 5: return \"JOG\";\n                case 6: return \"Teach in JOG\";\n                case 7: return \"Teach in HND\";\n                case 8: return \"INC\";\n                case 9: return \"REF\";\n                case 10: return \"RMT\";\n                default: return \"UNAVAILABLE\";\n            }\n        }\n</code></pre> The <code>GetMode()</code> method retrieves the current machine mode. It first checks if a valid Focas handle exists. If not, it prints \"Get a handle\" and returns an empty string.</p> <p>It creates an instance of the <code>Focas1.ODBST</code> structure to store the mode information. Then it calls the <code>cnc_statinfo</code> function to retrieve the mode data using the Focas handle. The return value is stored in the <code>_ret</code> variable.</p> <p>If an error occurs during the retrieval (return value is not equal to 0), it prints \"Error: Cannot obtain mode data\" and returns an empty string.</p> <p>Otherwise, it uses a <code>switch</code> statement on the <code>mode.aut</code> value to determine the mode and returns the corresponding string representation.</p> <p><pre><code>        public static string GetStatus()\n        {\n            if (_handle == 0)\n            {\n                Console.WriteLine(\"Get a handle\");\n                return \"\";\n            }\n\n            Focas1.ODBST status = new Focas1.ODBST();\n            _ret = Focas1.cnc_statinfo(_handle, status);\n\n            if (_ret != 0)\n            {\n                Console.WriteLine(\"Error: Cannot obtain status data\");\n                return \"\";\n            }\n\n            switch (status.run)\n            {\n                case 0: return \"*****\";\n                case 1: return \"STOP\";\n                case 2: return \"HOLD\";\n                case 3: return \"STRT\";\n                case 4: return \"MSTR\";\n                default: return \"UNAVAILABLE\";\n            }\n        }\n</code></pre> The <code>GetStatus()</code> method retrieves the current machine status. It follows a similar structure as the <code>GetMode()</code> method.</p> <p>It first checks if a valid Focas handle exists. If not, it prints \"Get a handle\" and returns an empty string</p> <p>.</p> <p>It creates an instance of the <code>Focas1.ODBST</code> structure to store the status information. Then it calls the <code>cnc_statinfo</code> function to retrieve the status data using the Focas handle. The return value is stored in the <code>_ret</code> variable.</p> <p>If an error occurs during the retrieval (return value is not equal to 0), it prints \"Error: Cannot obtain status data\" and returns an empty string.</p> <p>Otherwise, it uses a <code>switch</code> statement on the <code>status.run</code> value to determine the status and returns the corresponding string representation.</p> <pre><code>        public static void GetExecutionProgram()\n        {\n            if (_handle == 0)\n            {\n                Console.WriteLine(\"Get a handle\");\n                return;\n            }\n\n            Focas1.ODBEXEPRG prg_info = new Focas1.ODBEXEPRG();\n\n            _ret = Focas1.cnc_exeprgname(_handle, prg_info);\n\n            if (_ret != 0)\n            {\n                Console.WriteLine(\"Error: Cannot obtain program data\");\n                return;\n            }\n            string programName = new string(prg_info.name).TrimEnd('\\0');\n\n            Console.WriteLine($\"Executing Program Name: {programName}\");\n        }\n    }\n}\n</code></pre> <p>The <code>GetExecutionProgram()</code> method retrieves the name of the currently executing program on the machine.</p> <p>It first checks if a valid Focas handle exists. If not, it prints \"Get a handle\" and returns.</p> <p>It creates an instance of the <code>Focas1.ODBEXEPRG</code> structure to store the program information. Then it calls the <code>cnc_exeprgname</code> function to retrieve the program data using the Focas handle. The return value is stored in the <code>_ret</code> variable.</p> <p>If an error occurs during the retrieval (return value is not equal to 0), it prints \"Error: Cannot obtain program data\" and returns.</p> <p>Otherwise, it converts the program name from a null-terminated character array to a string by creating a new string and trimming the null character (<code>'\\0'</code>) at the end. The program name is then printed to the console.</p> <p>That's a walkthrough of the provided code! It connects to a FANUC CNC machine, retrieves and prints information about the machine's mode, status, and active program in a continuous loop. It handles graceful program termination and cleanup when necessary.</p>"},{"location":"General%20Knowledge/KPI%20in%20Manufacturing/","title":"KPI in Manufacturing","text":""},{"location":"General%20Knowledge/KPI%20in%20Manufacturing/#six-big-losses","title":"Six Big Losses","text":"<p>The Six Big Losses are a key concept in Total Productive Maintenance (TPM) and Overall Equipment Effectiveness (OEE). They represent the most common causes of efficiency loss in manufacturing. Here they are:</p> <ol> <li> <p>Downtime Loss (Mapped to Availability in OEE) </p> <ul> <li>Breakdowns: These are instances of equipment failure that result in unscheduled downtime. They can be caused by tooling failures, unplanned maintenance, equipment breakdown, etc.</li> <li>Setup and Adjustments: This refers to the time taken to change over from one product variant to another. It includes setup and adjustment time during which the equipment is not operational.</li> <li>Idling and Small Stops: These are minor stops or pauses in the production process that are usually less than 5 minutes and do not require maintenance personnel. They can be caused by issues like a blocked sensor or a minor jam.</li> </ul> </li> <li> <p>Speed Loss (Mapped to Performance in OEE)</p> <ul> <li>Reduced Speed: This refers to instances where the machinery is operating, but not at its optimal speed. This could be due to wear and tear, equipment issues, or sub-optimal operating conditions.</li> </ul> </li> <li> <p>Defect Loss (Mapped to Quality in OEE)</p> <ul> <li>Startup Rejects: These are defects that occur during the startup phase of production. When equipment is first started, it may take a while for it to operate correctly, resulting in defective output.</li> <li>Production Rejects: These are defects that occur during steady-state production. Despite the equipment running as expected, there can still be quality losses due to factors like tool wear or process variation.<ul> <li>Rework: These are defects that can be rectified by some rework.</li> <li>Scrap: These are defects that cannot be rectified and are scraped.</li> </ul> </li> </ul> </li> </ol> <p>By identifying and targeting these Six Big Losses, manufacturers can significantly improve their OEE and overall productivity.</p>"},{"location":"General%20Knowledge/Manufacturing%20Management/","title":"Management Concepts","text":""},{"location":"General%20Knowledge/Manufacturing%20Management/#shifts-in-manufacturing","title":"Shifts in Manufacturing","text":"<p>A shift is a period of time during which a group of workers performs their duties. Shifts are typically 8 hours long, but they can be longer or shorter depending on the needs of the company.</p> <p>Manufacturing companies often use shifts to keep their operations running 24 hours a day, 7 days a week. This is especially important for companies that produce essential goods, such as food, medicine, and energy.</p> <p>There are many different ways to schedule shifts in a manufacturing company. One common approach is to use a rotating shift schedule. In this type of schedule, workers rotate between different shifts on a regular basis. This helps to ensure that everyone has a fair share of working day shifts and night shifts.</p> <p>Another common approach is to use a fixed shift schedule. In this type of schedule, workers are assigned to a specific shift and work that shift every day. This type of schedule can be beneficial for workers who prefer to have a regular routine.</p> <p>Here is an example of a typical shift schedule in a manufacturing company:</p> <ul> <li> <p>Shift 1: 6:00 AM - 2:00 PM</p> </li> <li> <p>Shift 2: 2:00 PM - 10:00 PM</p> </li> <li> <p>Shift 3: 10:00 PM - 6:00 AM</p> </li> </ul> <p>Each shift would have its own group of workers who are responsible for operating the machinery and producing the products. The workers would typically rotate between shifts on a weekly basis, so that everyone has a chance to work day shifts and night shifts.</p> <p>Shift work can be challenging, but it is also an important part of many manufacturing companies. By using shifts, these companies can keep their operations running 24/7 and produce the goods that we all rely on.</p> <p>Key point to remeber is that, shift is a concept of factory and group of workers.</p>"},{"location":"General%20Knowledge/Manufacturing%20Management/#ramifications-of-shift-in-kpi-calculations","title":"Ramifications of Shift in KPI calculations","text":"<p>One thing to remember is that our KPIs should go down only if there is something wrong with the machine/resource/enviroment. Look at the following case, lets say we have two shifts, and lets say the a machine (1) was not planned to be run, then its actual production time would be zero, which will result in availabilty becoming zero (by raw formula calculation), meaning it has decreased, which means something is wrong with the machine, but we did not plan to run the machine, hence there is nothing wrong with the machine, hence the availability should be set to 100.</p> <p>When the shift changes, the parameters that affect the KPI parameters will need to be reset to zero, such as actual production time, ideal cycle time, actual total number of parts. (applicable only for parameter for shift and day based, cumulative will stay unaffected).</p> <p>And when calculating KPI for the individual machines (whole factory) we need to make sure that the machine was acutally planned to be run in that shift, if not, then that duration should not be added to the planned production time</p> <p>This could be done by checking that the current machine was planned to run in the current shift and also if the machine was planned to run, and has finished the planned number of parts during that shift  {early finish}, then the remaining time should not be added to the planned production {since that would decrease the KPI, since the actual production will not increase}, so we should check if the machine was planned to be run in this shift, and also check if the total part count is less than the planned part count.</p>"},{"location":"General%20Knowledge/OPC%20UA/","title":"OPC UA","text":""},{"location":"General%20Knowledge/OPC%20UA/#introduction","title":"Introduction","text":"<p>OPC UA (Open Platform Communications Unified Architecture) is a device-to-device communication protocol for industrial automation and industrial IoT (Internet of Things) applications. It is a widely adopted and standardized protocol designed to enable seamless and secure communication between various devices and systems in industrial environments.</p> <p>Here are some key aspects of OPC UA:</p> <ol> <li> <p>Architecture: OPC UA follows a client-server architecture, where one or more clients communicate with one or more servers. Clients can request data, perform operations, and subscribe to real-time data from servers. Servers provide access to data and services and respond to client requests.</p> </li> <li> <p>Interoperability: OPC UA is designed to facilitate interoperability among devices and systems from different vendors. It provides a common framework for communication and data exchange, ensuring that different devices can communicate with each other regardless of the underlying hardware, operating system, or programming language.</p> </li> <li> <p>Data Modeling: OPC UA allows for flexible and extensible data modeling. It defines a standardized information model that enables the representation of various types of data, such as process data, alarms, events, historical data, and more. This modeling capability allows for consistent and meaningful data exchange between different systems.</p> </li> <li> <p>Security: Security is a crucial aspect of OPC UA. It incorporates robust security measures to protect the integrity, confidentiality, and authenticity of data exchanged between devices and systems. OPC UA supports encryption, authentication, access control, and secure channel establishment to ensure secure communication in industrial networks.</p> </li> <li> <p>Platform Independence: OPC UA is designed to be platform-independent, meaning it can run on different operating systems and hardware architectures. This flexibility allows OPC UA to be implemented in a wide range of devices, including sensors, programmable logic controllers (PLCs), human-machine interfaces (HMIs), and enterprise systems.</p> </li> <li> <p>Services and Functionality: OPC UA provides a rich set of services and functionality for various industrial automation scenarios. It supports services like data access, event subscriptions, method calls, historical data access, alarms, and more. These services enable real-time and historical data exchange, remote monitoring and control, and integration with higher-level enterprise systems.</p> </li> <li> <p>Scalability and Performance: OPC UA is designed to handle large-scale industrial systems and networks. It offers features like publish-subscribe communication patterns, high-performance data access, and support for efficient data compression. These capabilities allow OPC UA to scale to meet the requirements of diverse industrial environments.</p> </li> </ol> <p>Overall, OPC UA is widely regarded as a robust and secure communication protocol for industrial automation. Its flexibility, interoperability, and standardized approach make it a preferred choice for integrating diverse devices, systems, and applications in industrial settings.</p>"},{"location":"General%20Knowledge/OPC%20UA/#open62541","title":"Open62541","text":"<p>open62541 is an open-source implementation of the OPC UA (Open Platform Communications Unified Architecture) protocol stack. It provides a C-based library that enables developers to create OPC UA client and server applications. The name \"open62541\" comes from the fact that it adheres to the OPC UA specification and is implemented in C, and \"62541\" is the OPC UA specification number.</p> <p>Here are some key points about open62541:</p> <ol> <li> <p>Open-Source Implementation: open62541 is an open-source project released under the Mozilla Public License (MPL) 2.0. This means that the source code is freely available, allowing developers to inspect, modify, and distribute it as per the terms of the license.</p> </li> <li> <p>OPC UA Compliance: open62541 aims to provide compliance with the OPC UA specifications defined by the OPC Foundation. It supports the core OPC UA features, including secure communication, data modeling, services, and functionality, to enable interoperability with other OPC UA compliant systems.</p> </li> <li> <p>C-Based Library: open62541 is implemented in C programming language, making it suitable for a wide range of platforms and environments. The library provides an API that developers can use to build OPC UA client and server applications from scratch or integrate OPC UA functionality into existing systems.</p> </li> <li> <p>Modularity and Customization: open62541 is designed with modularity in mind, allowing developers to enable or disable specific features based on their requirements. It offers flexibility in terms of configuring security policies, network transports, and data modeling options to adapt to various industrial scenarios.</p> </li> <li> <p>Scalability and Performance: open62541 is built to handle scalable and high-performance OPC UA applications. It utilizes asynchronous communication and multi-threading to handle multiple client connections efficiently. It also includes features like data exchange optimization, subscriptions, and history management to support real-time and historical data processing.</p> </li> <li> <p>Community and Support: open62541 has an active community of developers and contributors who provide support, bug fixes, and improvements to the project. The community forum and GitHub repository serve as platforms for discussions, issue tracking, and collaboration among users.</p> </li> <li> <p>Integration and Extensibility: open62541 can be integrated with various software platforms, frameworks, and hardware devices. It offers extensibility through plugins and custom extensions, enabling developers to add additional functionality or integrate with existing systems seamlessly.</p> </li> </ol> <p>Overall, open62541 is a powerful open-source implementation of the OPC UA protocol stack, providing a flexible and customizable framework for building OPC UA client and server applications. It offers developers the tools and libraries to enable secure and interoperable communication in industrial automation and IoT environments.</p>"},{"location":"General%20Knowledge/OPC%20UA/#net-stack","title":".Net Stack","text":"<p>The Standard .NET OPC UA Stack is a software framework developed by the OPC Foundation for implementing OPC UA client and server applications using the .NET platform. It provides a set of libraries and tools that enable developers to build OPC UA compliant applications in the .NET environment. The Standard .NET OPC UA Stack and open62541 are both implementations of the OPC UA protocol stack, but they differ in terms of their programming language, platform compatibility, and specific features.</p>"},{"location":"General%20Knowledge/OPC%20UA/#difference-between-net-stack-and-open62541","title":"Difference Between .Net Stack and open62541","text":"<p>Here are some key points highlighting the differences between the Standard .NET OPC UA Stack and open62541:</p> <ol> <li> <p>Programming Language: The Standard .NET OPC UA Stack is implemented in C# and is specifically designed for the .NET platform, leveraging the features and capabilities of the .NET framework. On the other hand, open62541 is implemented in C and can be used on a broader range of platforms, including those that do not have native support for the .NET framework.</p> </li> <li> <p>Platform Compatibility: The Standard .NET OPC UA Stack is primarily intended for use with the .NET framework and is well-suited for developing OPC UA applications on Windows-based systems. It provides seamless integration with other .NET technologies and tools. In contrast, open62541 is designed to be platform-independent and can be used on various operating systems, including Windows, Linux, and others.</p> </li> <li> <p>Features and Functionality: Both implementations strive to comply with the OPC UA specifications defined by the OPC Foundation. However, there may be some differences in terms of specific features and functionality offered by each stack. The Standard .NET OPC UA Stack provides a rich set of APIs and tools that align closely with the .NET framework, making it easier to develop OPC UA applications within the .NET ecosystem. open62541, being a C-based library, offers flexibility and customization options and can be used in a wide range of scenarios.</p> </li> <li> <p>Community and Support: Both the Standard .NET OPC UA Stack and open62541 have active communities of developers and users. The OPC Foundation provides support and resources for the Standard .NET OPC UA Stack, including documentation, examples, and forums. open62541 also has an active community on GitHub, where users can collaborate, report issues, and contribute to the project.</p> </li> </ol> <p>In summary, the Standard .NET OPC UA Stack and open62541 are both implementations of the OPC UA protocol stack, but they differ in terms of programming language, platform compatibility, and specific features. The choice between them depends on factors such as the targeted platform, programming language preference, and the specific requirements of the application.</p>"},{"location":"General%20Knowledge/OPC%20UA/#extending-opc-ua-servers","title":"Extending OPC UA Servers","text":"<p>When working with OPC UA servers, it is possible to create an extended server that inherits the nodes and parameters from another OPC UA server while introducing additional sets of nodes and parameters. This allows for the customization and expansion of functionality based on specific requirements.</p>"},{"location":"General%20Knowledge/OPC%20UA/#can-an-opc-ua-server-extend-another-server-by-adding-new-nodes-and-parameters","title":"Can an OPC UA server extend another server by adding new nodes and parameters?","text":"<p>Yes, it is possible to create an OPC UA server that extends another OPC UA server. By following server hierarchies and utilizing OPC UA's object-oriented models, an extended server can inherit the existing nodes and parameters from the base server while introducing new sets of nodes and parameters specific to the extended server.</p>"},{"location":"General%20Knowledge/OPC%20UA/#handling-requests-for-inherited-and-new-nodesparameters","title":"Handling requests for inherited and new nodes/parameters","text":"<p>To achieve the desired behavior where the extended server can provide data from the inherited server for common nodes/parameters and its own data for new nodes/parameters, the following steps can be implemented:</p> <ol> <li> <p>Handle requests for common nodes/parameters: When a client requests a common node or parameter that is inherited from the base server, the extended server acts as a proxy and forwards the request to the base server to retrieve the data.</p> </li> <li> <p>Respond to requests for new nodes/parameters: When a client requests a node or parameter that is specific to the extended server and not available in the base server, the extended server can handle those requests directly by providing the data from its own implementation.</p> </li> </ol> <p>By implementing this logic, the extended OPC UA server seamlessly combines data from the inherited server and provides its own data for new nodes/parameters, delivering a unified and customized experience to OPC UA clients.</p> <p>Please note that the implementation details may vary depending on the OPC UA stack or framework being used. The specific APIs, methods, and event handlers provided by the stack will determine how to handle requests and retrieve data from the base server or the extended server's own implementation.</p>"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/","title":"Intro","text":""},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#raw-data","title":"Raw Data","text":"<p>Most of the machine will expose certain raw data, which can be used along with other sets of data to find the KPIs. The raw data available/required are:</p> <ol> <li> <p>Operating Mode:     This refers to the mode of operation in the cnc machine, for example, <code>MEM</code> is memory mode, in this CNC system runs programs stored in its memory. This mode is also known as the automatic mode, where the CNC machine loads the entire G Code file into its memory and executes it automatically, without any manual intervention. In this mode, the machine follows the instructions provided in the G Code file from start to finish. The entire code is executed sequentially, allowing for a fully automated operation. The machine takes care of executing each command in the G Code file without requiring any further input or interaction from the operator.</p> <p>In the execution of this project, finding out when the machine is in <code>MEM</code> mode is crucial, as this denotes the fact the production of a part has started (anything operation that isdone in other mode such as say <code>Edit</code> mode will usually be considered as non productive time, hence will contribute to prouction loss).</p> </li> <li> <p>Program Status:     This refers to the status of the program that is loaded in memory (if nothing is loaded, then a default value such as 0 might be returned). For example a number of 3 from the machine might denote that the program is started and a value of 1 might mean the program got over. In most of the cases in the machine, we might have to do some trail experiments to see what those numbers represent.</p> </li> <li> <p>Machine Status:     This refers to the staus of machine, which could (mostly) take one of the values: <code>PRODUCTION</code>, <code>IDLE</code>, <code>OFF</code>, or something similar to that. This parameter could sometime be retrieved as raw data, or it might be takes as a derived information from the operating mode and program status. This data is important to understand how much the machine was utilized. When this information is not available directly when get it as follows: </p> <pre><code>1. If operating mode is ``auto`` &amp;&amp; program status is ``start`` (or anything similar) then the machine is in ``PRODUCTION``\n2. If any other combination if operation mode and program status then the machine is in ``IDLE`` status.\n3. If no data is coming the machine is in ``OFF`` status.\n</code></pre> </li> <li> <p>Program Name:     This represents the program name that is being currently executed by the machine. This is an important information to find details such as idle cycle time for a given program, which in turn will be used to find the performace and oee metrics.</p> </li> </ol>"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#oee-metrics2","title":"OEE Metrics2","text":"<p>The final KPI that we need to show are listed below:</p> <ol> <li>Availability<ul> <li>For current shift</li> <li>For current day</li> <li>For cumulative (since the beginning of the project)</li> </ul> </li> <li>Performance<ul> <li>For current shift</li> <li>For current day</li> <li>For cumulative</li> </ul> </li> <li>Quality<ul> <li>For current shift</li> <li>For current day</li> <li>For cumulative</li> </ul> </li> <li>OEE<ul> <li>For current shift</li> <li>For current day</li> <li>For cumulative </li> </ul> </li> </ol>"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#calculations-2","title":"Calculations 2","text":"<p>In this section we will show how to calculate all the above KPIs.</p> <ol> <li>Availablity: </li> </ol> <p>The formula for availability is given by:</p> \\[ \\text{Availability} = \\frac{\\text{Actual Production Time}}{\\text{Planned Production Time}} \\]"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#case-1-machine-state-change-from-production-to-idle","title":"CASE 1 (Machine state change from production to idle)","text":"<p>Let's say the machine has changed its state from production to idle just now, we need to have the following data</p> <p>Start time of (previous) production cycle : 31-05-2023T11:15:03 </p> <p>End time of production cycle (just now) : 31-05-2023T11:19:22</p> <ol> <li> <p>Find the planned production time for the given duration:</p> <ol> <li>We can see that from the planned event timeline, the production start and end datetime falls under prodution (full time), hence the planned production time for the given query time duration is the query time duration itself (which is 31-05-2023T11:19:22 - 31-05-2023T11:15:03 = 289 s). (Usually the production will be done in planned production time, hence by default it will be equal to the difference between end and start time, we can hopefully skip the part where we have to check if the production was done during any of the planned production time).</li> </ol> \\[ \\text{Planned Production Time} = \\text{289} \\] </li> <li> <p>Find the Actual Production Time:</p> <p>The actual production time is same as the difference between the end and start time.</p> \\[ \\text{Actual Production Time} = \\text{289} \\] </li> <li> <p>Find Availability:</p> <ol> <li>By substituting in the previous formula we can find the value</li> </ol> \\[ \\text{Availability} = \\frac{\\text{289}}{\\text{289}} \\] \\[ \\text{Availability} = {\\text{1}} \\] \\[ \\text{Availability \\%} = {\\text{100 \\%}} \\] </li> </ol>"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#case-machine-state-change-from-idle-to-production","title":"CASE  (Machine state change from idle to production)","text":"<p>Let's say the machine has changed its state from idle to production just now, we need to have the following data</p> <p>Start time of idle time : 31-05-2023T11:15:03 </p> <p>End time of idle (just now) : 31-05-2023T11:19:22</p> <ol> <li> <p>Find the planned production time for the given duration:</p> <ol> <li>We can see that from the planned event timeline, the production start and end datetime falls under prodution (full time), hence the planned production time for the given query time duration is the query time duration itself (which is 31-05-2023T11:19:22 - 31-05-2023T11:15:03 = 289 s). (Usually the production will be done in planned production time, hence by default it will be equal to the difference between end and start time, we can hopefully skip the part where we have to check if the production was done during any of the planned production time).</li> </ol> \\[ \\text{Planned Production Time} = \\text{289} \\] </li> <li> <p>Find the Actual Production Time:</p> <p>The actual production time is same as the difference between the end and start time.</p> \\[ \\text{Actual Production Time} = \\text{289} \\] </li> <li> <p>Find Availability:</p> <ol> <li>By substituting in the previous formula we can find the value</li> </ol> \\[ \\text{Availability} = \\frac{\\text{289}}{\\text{289}} \\] \\[ \\text{Availability} = {\\text{1}} \\] \\[ \\text{Availability \\%} = {\\text{100 \\%}} \\] </li> </ol>"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#calculations","title":"Calculations","text":"<p>In this section we will show how to calculate all the above KPIs.</p>"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#oee-metrics","title":"OEE Metrics","text":"<p>Since there is not much production going in CMTI, and due to lack of systematic method for manufacturing, we're are using a different approach to calculate the KPIs, which will not reflect the actual performance of the plant and machine, but for the sake of demonstration we have to do this.</p> <p>Let's explain the calculation with a sample data shown below:</p> <p>Machine Production Timeline:</p> S.No Machine Name Start Time End Time Duration* Ideal Time Product Name Program Name Part Status 1. MCV - 450 31-05-2023T11:15:03 31-05-2023T11:17:09 126 120 CNC_DRILL_1 crank_feature_1 1 2. MCV - 450 31-05-2023T11:17:45 31-05-2023T11:19:22 127 120 CNC_DRILL_1 crank_feature_1 2 <p>* Sometime the duration column in the above table will not be exactly equal to the difference between end and start time columns, reason is, the machine could have been stopped in the middle of production for minor adjustments, which could be seen in the machine status timeline table.</p> <p>Part Status Desctiption Table:</p> Id (PK) Part Status Description Category 1. Good This denotes the part is of good quality and was manufactured according the given tolerances good 2. rework_start_up This denotes the part is was of bad quality but it could be made good by rework, it was part of the start up phase of the production, where fault will be usually high loss_start_up 3. scrap_start_up This denotes the part is was of bad quality and cannot be reworked, it was part of the start up phase of the production, where fault will be usually high loss_start_up 4. rework_production This denotes the part is was of bad quality but it could be made good by rework, it was part of the production phase of the production, where fault will be usually low loss_production 5. scrap_production This denotes the part is was of bad quality and cannot be reworked, it was part of the production phase of the production, where fault will be usually low loss_production <p>Machine Status Timeline:</p> S.No Machine Name Start Time End Time Duration Machine State Label Label Value 1. MCV - 450 31-05-2023T11:15:03 31-05-2023T11:17:09 126 production program name crank_feature_1 2. MCV - 450 31-05-2023T11:17:09 31-05-2023T11:17:45 36 idle reason setup_and_adjustments 3. MCV - 450 31-05-2023T11:17:45 31-05-2023T11:19:22 127 production program name crank_feature_1 <p>Planned Event Timeline:</p> S.No Date Shift Start Time End Time Duration (s) 1. 31/05/2023 1 31-05-2023T8:00:00 31-05-2023T4:00:00 28800"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#availability","title":"Availability","text":"<p>The formula for availability is given by:</p> \\[ \\text{Availability} = \\frac{\\text{Actual Production Time}}{\\text{Planned Production Time}} \\] <p>Let's say we want to find the availability between </p> <p>Start time : 31-05-2023T11:15:03 </p> <p>End time: 31-05-2023T11:19:22</p> <ol> <li> <p>Find the planned production time for the given duration:</p> <ol> <li>We can see that from the planned event timeline, the query start and end datetime falls under prodution (full time), hence the planned production time for the given query time duration is the query time duration itself (which is 31-05-2023T11:19:22 - 31-05-2023T11:15:03 = 289 s).</li> </ol> \\[ \\text{Planned Production Time} = \\text{289} \\] </li> <li> <p>Find the Actual Production Time:</p> <ol> <li>The actual production time is given by summation of duration column in the Machine Production Timeline table for all rows where the start and end time is within the query range.</li> <li>For example in the current case: 126 + 127 = 253 seconds.</li> </ol> \\[ \\text{Actual Production Time} = \\text{253} \\] </li> <li> <p>Find Availability:</p> <ol> <li>By substituting in the previous formula we can find the value</li> </ol> \\[ \\text{Availability} = \\frac{\\text{253}}{\\text{289}} \\] \\[ \\text{Availability} = {\\text{0.8754}} \\] \\[ \\text{Availability \\%} = {\\text{87.54 \\%}} \\] </li> </ol>"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#performance","title":"Performance","text":"<p>The formula for Performance is given by:</p> \\[ \\text{Performance} = \\frac{\\text{Ideal Production Time}}{\\text{Actual Production Time}} \\] <ol> <li> <p>Find Ideal Production Time:</p> <ol> <li> <p>The ideal production time is determined by summing up the ideal cycle times for all the cycles that occurred between the given start and end time. For the solution deployed at cmti, this is available in the machine production timeline table, with the column name of <code>Ideal Time</code> . The collector which collects the data from the machine, will give a dummy data for this by taking a value that is between 90 % and 98 % of the actual duration time. This is something that we have to do, since there is no systematic way to get the ideal time in the current set up at cmti, and since we have to demonstrate a prototype we use some same value.</p> \\[ \\text{Ideal Production Time} = \\sum \\text{Ideal Cycle Times for All Cycles during the given Query Range} \\] </li> <li> <p>For example in the previous case, the following would be applicable</p> <p>120 + 120 = 240</p> \\[ \\text{Ideal Production Time } = {\\text{240}} \\] </li> </ol> </li> <li> <p>The actual production time is already found in previous metric(Availability):</p> </li> <li> <p>Find Performance</p> \\[ \\text{Performance} = \\frac{\\text{Ideal Production Time}}{\\text{Actual Production Time}} \\] \\[ \\text{Performance} = \\frac{\\text{240}}{\\text{253}} \\] \\[ \\text{Performance} = {\\text{0.9486}} \\] \\[ \\text{Performance \\%} = {\\text{94.86 \\%}} \\] </li> </ol>"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#quality","title":"Quality","text":"<p>The formula for Quality is given by </p> \\[ \\text{Quality} = \\frac{\\text{Good Parts Produced}}{\\text{Total Parts Produced}} \\] <ol> <li> <p>Total Parts:     This can be calculated by querying the table of machine production timeline, the total count equal to the number of rows with column 'Machine State' equal to production and </p> </li> <li> <p>The number of good parts is equal to the number of rows where the rejected is not equal to 'No'.</p> </li> <li> <p>For example in the above case </p> \\[ \\text{Quality} = \\frac{\\text{2}}{\\text{2}} \\] \\[ \\text{Quality } = {\\text{1}} \\] \\[ \\text{Quality \\%} = {\\text{100 \\%}} \\] </li> </ol>"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#overall-equipment-effectiveness-oee","title":"Overall Equipment Effectiveness (OEE)","text":"<p>The formula for OEE is given by </p> \\[ \\text{OEE} = {\\text{Availability}}\\times{\\text{Performance}}\\times{\\text{Quality}} \\] \\[ \\text{OEE} = {\\text{0.8754}}\\times{\\text{0.9486}}\\times{\\text{1}} \\] \\[ \\text{OEE} = {\\text{0.8304}} \\] \\[ \\text{OEE \\%} = {\\text{83.04 \\%}} \\]"},{"location":"Project%20Knowledge/KPI%20Calculations%20%28CMTI%29/#six-big-losses","title":"Six Big Losses","text":"<p>The Six Big Losses are a key concept in Total Productive Maintenance (TPM) and Overall Equipment Effectiveness (OEE). They represent the most common causes of efficiency loss in manufacturing. Here they are:</p> <ol> <li> <p>Downtime Loss (Mapped to Availability in OEE) </p> <ul> <li> <p>Breakdowns: These are instances of equipment failure that result in unscheduled downtime. They can be caused by tooling failures, unplanned maintenance, equipment breakdown, etc.</p> </li> <li> <p>Setup and Adjustments: This refers to the time taken to change over from one product variant to another. It includes setup and adjustment time during which the equipment is not operational.</p> </li> <li> <p>Idling and Small Stops: These refer to minor stops or pauses in the production process that last for less than 5 minutes and do not require maintenance personnel. They can occur due to issues like a blocked sensor, a minor jam, or idle time during part changeover.</p> </li> <li> <p>It is the collector's responsibility to accurately identify the reason for the machine's idle state. One simple method is to categorize durations less than 5 minutes as \"Idling and Small Stops,\" durations between 5 minutes and 2 hours as \"Setup and Adjustments,\" and durations exceeding 2 hours as \"Breakdowns.\"</p> </li> <li> <p>Calculation: To calculate the losses associated with these conditions within a specific time range, we need to query the <code>Machine Status Timeline</code> table for that range, focusing on entries where the <code>Machine State</code> column indicates an idle or off condition. For cumulative downtime, we sum the duration values across all corresponding rows related to the above conditions. To obtain individual values, we further filter the rows based on the label column, using the following criteria:</p> <ul> <li> <p>Breakdowns: Select entries where the machine state is idle or off, and the label value is <code>breakdown</code>.</p> </li> <li> <p>Setup and Adjustments: Select entries where the machine state is idle or off, and the label value is <code>setup and adjustments</code>.</p> </li> <li> <p>Idling and Small Stops: Select entries where the machine state is idle or off, and the label value is <code>idling and small stops</code>.</p> </li> </ul> </li> </ul> </li> <li> <p>Speed Loss (Mapped to Performance in OEE)</p> <ul> <li> <p>Reduced Speed: This refers to instances where the machinery is operating, but not at its optimal speed. This could be due to wear and tear, equipment issues, or sub-optimal operating conditions.</p> </li> <li> <p>Calculation: The formula for reeduced speed loss is given by the following formula, and it is almost similar to calculation of performance</p> \\[ \\text{Reduced Speed Loss} = \\frac{\\text{Actual Production Time - Ideal Production Time}}{\\text{Actual Production Time}} \\] </li> </ul> </li> <li> <p>Defect Loss (Mapped to Quality in OEE)</p> <ul> <li> <p>Startup Rejects: These are defects that occur during the startup phase of production. When equipment is first started, it may take a while for it to operate correctly, resulting in defective output.</p> </li> <li> <p>Calculation: To determine the start-up reject loss within a given time range, you can refer to the <code>Machine Production Timeline</code> table. By filtering out the rows with a <code>Part Status</code> column value of either 2 or 3, corresponding to <code>rework_start_up</code> or <code>scrap_start_up</code> in the Part Status Description Table, you can identify the start-up reject instances. Let's assume there are 3 such rows. To calculate the start-up reject loss, you need to consider the total number of parts produced during that time range, which includes both good and bad parts. This can be determined by counting the total number of rows in the table within the specified time range, let's say it's 10. The start-up reject loss can then be calculated as follows:</p> \\[ \\text{Startup Rejects Loss} = \\frac{\\text{Bad Parts Produced During Start Up}}{\\text{Total Parts Produced}} \\] \\[ \\text{Startup Rejects Loss} = \\frac{\\text{3}}{\\text{10}} \\] \\[ \\text{Startup Rejects Loss \\%} = \\text{30 \\%} \\] </li> <li> <p>Production Rejects: These are defects that occur during steady-state production. Despite the equipment running as expected, there can still be quality losses due to factors like tool wear or process variation.</p> </li> <li> <p>Calculation: To determine the start-up reject loss within a given time range, you can refer to the <code>Machine Production Timeline</code> table. By filtering out the rows with a <code>Part Status</code> column value of either 4 or 5, corresponding to <code>rework_production</code> or <code>scrap_production</code> in the Part Status Description Table, you can identify the production reject instances. Let's assume there are 2 such rows. To calculate the production reject loss, you need to consider the total number of parts produced during that time range, which includes both good and bad parts. This can be determined by counting the total number of rows in the table within the specified time range, let's say it's 10. The production reject loss can then be calculated as follows:</p> \\[ \\text{Production Rejects Loss} = \\frac{\\text{Bad Parts Produced During Production}}{\\text{Total Parts Produced}} \\] \\[ \\text{Production Rejects Loss} = \\frac{\\text{2}}{\\text{10}} \\] \\[ \\text{Production Rejects Loss \\%} = \\text{20 \\%} \\] </li> <li> <p>To classify the losses into rework and scrap categories, we can apply additional filtering based on the Part Status column value. Specifically, we can include values 2, 3, 4, or 5, which correspond to different types of losses: rework loss during start-up, scrap loss during start-up, rework loss during production, and scrap loss during production, respectively. By filtering the Part Status column to only include these values, we can further categorize the losses accordingly.</p> </li> </ul> </li> </ol> <p>By identifying and targeting these Six Big Losses, manufacturers can significantly improve their OEE and overall productivity.</p>"},{"location":"Project%20Knowledge/KPI%20Calculations/","title":"OEE Metrics","text":"<p>Let's explain the calculation with a sample data shown below:</p> <p>Machine Status Timeline:</p> S.No Machine Name Start Time End Time Duration Machine State Label Label Value Rejected Part 1. MCV - 450 31-05-2023T11:15:03 31-05-2023T11:17:09 126 production program name crank_feature_1 no 2. MCV - 450 31-05-2023T11:17:09 31-05-2023T11:17:45 36 idle reason part_change nil 3. MCV - 450 31-05-2023T11:17:45 31-05-2023T11:19:22 127 production program name crank_feature_1 no <p>Planned Event Timeline:</p> S.No Date Shift Start Time End Time Duration (s) 1. 31/05/2023 1 31-05-2023T8:00:00 31-05-2023T4:00:00 28800 <p>Part Program Meta Data:</p> S.No Machine Name Program Name Ideal Cycle Time (s) 1. MCV - 450 crank_feature_1 120"},{"location":"Project%20Knowledge/KPI%20Calculations/#availability","title":"Availability","text":"<p>The formula for availability is given by:</p> \\[ \\text{Availability} = \\frac{\\text{Actual Production Time}}{\\text{Planned Production Time}} \\] <p>Let's say we want to find the availability between </p> <p>Start time : 31-05-2023T11:15:03 </p> <p>End time: 31-05-2023T11:19:22</p> <ol> <li> <p>Find the planned production time for the given duration:</p> <ol> <li>We can see that from the planned event timeline, the query start and end datetime falls under prodution (full time), hence the planned production time for the given query time duration is the query time duration itself (which is 31-05-2023T11:19:22 - 31-05-2023T11:15:03 = 289 s).</li> </ol> \\[ \\text{Planned Production Time} = \\text{289} \\] </li> <li> <p>Find the Actual Production Time:</p> <ol> <li>The actual production time is given by summation of duration column in the Machine Status Timeline table for all rows where the machine state column has value production.</li> <li>For example in the current case: 126 + 127 = 253 seconds.</li> </ol> \\[ \\text{Actual Production Time} = \\text{253} \\] </li> <li> <p>Find Availability:</p> <ol> <li>By substituting in the previous formula we can find the value</li> </ol> \\[ \\text{Availability} = \\frac{\\text{253}}{\\text{289}} \\] \\[ \\text{Availability} = {\\text{0.8754}} \\] \\[ \\text{Availability \\%} = {\\text{87.54 \\%}} \\] </li> </ol>"},{"location":"Project%20Knowledge/KPI%20Calculations/#performance","title":"Performance","text":"<p>The formula for Performance is given by:</p> \\[ \\text{Performance} = \\frac{\\text{Ideal Production Time}}{\\text{Actual Production Time}} \\] <ol> <li> <p>Find Ideal Production Time:</p> <ol> <li> <p>The ideal production time is determined by summing up the ideal cycle times for all the cycles that occurred between the given start and end time. To calculate this, we require information from two tables. First, we utilize the machine status time line table, which provides the start and end times of all the cycles that took place within the specified query start and end time, along with the corresponding part program name for each cycle. Secondly, we need to access the Part Program Meta Data table to obtain the ideal cycle time associated with each part program name. Once we have this information, we can add up the ideal cycle times to obtain the ideal production time. It is important to note that performing a SQL join operation on these two tables is necessary to accomplish this calculation.</p> \\[ \\text{Ideal Production Time} = \\sum \\text{Ideal Cycle Times for All Cycles during the given Query Range} \\] </li> <li> <p>For example in the previous case, the following table gives all the production cycles along with the part program name</p> <ol> <li> <p>Machine Status Timeline:</p> S.no Machine Name Start Time End Time Duration Machine State Label Label Value 1. MCV - 450 31-05-2023T11:15:03 31-05-2023T11:17:09 126 production program name crank_feature_1 3. MCV - 450 31-05-2023T11:17:45 31-05-2023T11:19:22 127 production program name crank_feature_1 </li> <li> <p>The corresponding part program name is given below:</p> <p>Part Program Meta Data:</p> S.No Machine Name Program Name Ideal Cycle Time (s) 1. MCV - 450 crank_feature_1 120 </li> <li> <p>Hence the sum would be 120 + 120 = 240</p> </li> </ol> \\[ \\text{Ideal Production Time } = {\\text{240}} \\] </li> </ol> </li> <li> <p>Sometime the ideal part program cycle time would not be available, it is the end user / developers responsibility to somehow update the values (Such as in cmti, it is not available, since we don't usually use cam softwares here.)</p> <ol> <li>One possible strategy is to update the part program's ideal cycle time to be equal to the minimum value of the set of cycle times (from the machine status timeline table, from duration column, when the machine state is production), at least this will ensure that we're comparing the cycle time to the lowest that was achieved by the machine.</li> </ol> </li> <li> <p>The actual production time is already found in previous metric(Availability):</p> </li> <li> <p>Find Performance</p> \\[ \\text{Performance} = \\frac{\\text{Ideal Production Time}}{\\text{Actual Production Time}} \\] \\[ \\text{Performance} = \\frac{\\text{240}}{\\text{253}} \\] \\[ \\text{Performance} = {\\text{0.9486}} \\] \\[ \\text{Performance \\%} = {\\text{94.86 \\%}} \\] </li> </ol>"},{"location":"Project%20Knowledge/KPI%20Calculations/#quality","title":"Quality","text":"<p>The formula for Quality is given by </p> \\[ \\text{Quality} = \\frac{\\text{Good Parts Produced}}{\\text{Total Parts Produced}} \\] <ol> <li> <p>Total Parts:     This can be calculated by querying the table of machine status timeline, the total count equal to the number of rows with column 'Machine State' equal to production and </p> </li> <li> <p>The number of good parts is equal to the number of rows where the rejected is not equal to 'No'.</p> </li> <li> <p>For example in the above case </p> \\[ \\text{Quality} = \\frac{\\text{2}}{\\text{2}} \\] \\[ \\text{Quality } = {\\text{1}} \\] \\[ \\text{Quality \\%} = {\\text{100 \\%}} \\] </li> </ol>"},{"location":"Project%20Knowledge/KPI%20Calculations/#overall-equipment-effectiveness-oee","title":"Overall Equipment Effectiveness (OEE)","text":"<p>The formula for OEE is given by </p> \\[ \\text{OEE} = {\\text{Availability}}\\times{\\text{Performance}}\\times{\\text{Quality}} \\] \\[ \\text{OEE} = {\\text{0.8754}}\\times{\\text{0.9486}}\\times{\\text{1}} \\] \\[ \\text{OEE} = {\\text{0.8304}} \\] \\[ \\text{OEE \\%} = {\\text{83.04 \\%}} \\]"},{"location":"Project%20Knowledge/KPI%20Calculations/#six-big-losses","title":"Six Big Losses","text":"<p>The Six Big Losses are a key concept in Total Productive Maintenance (TPM) and Overall Equipment Effectiveness (OEE). They represent the most common causes of efficiency loss in manufacturing. Here they are:</p> <ol> <li> <p>Downtime Loss (Mapped to Availability in OEE) </p> <ul> <li>Breakdowns: These are instances of equipment failure that result in unscheduled downtime. They can be caused by tooling failures, unplanned maintenance, equipment breakdown, etc.</li> <li>Setup and Adjustments: This refers to the time taken to change over from one product variant to another. It includes setup and adjustment time during which the equipment is not operational.</li> <li>Idling and Small Stops: These are minor stops or pauses in the production process that are usually less than 5 minutes and do not require maintenance personnel. They can be caused by issues like a blocked sensor or a minor jam.</li> </ul> </li> <li> <p>Speed Loss (Mapped to Performance in OEE)</p> <ul> <li>Reduced Speed: This refers to instances where the machinery is operating, but not at its optimal speed. This could be due to wear and tear, equipment issues, or sub-optimal operating conditions.</li> </ul> </li> <li> <p>Defect Loss (Mapped to Quality in OEE)</p> <ul> <li>Startup Rejects: These are defects that occur during the startup phase of production. When equipment is first started, it may take a while for it to operate correctly, resulting in defective output.</li> <li>Production Rejects: These are defects that occur during steady-state production. Despite the equipment running as expected, there can still be quality losses due to factors like tool wear or process variation.<ul> <li>Rework: These are defects that can be rectified by some rework.</li> <li>Scrap: These are defects that cannot be rectified and are scraped.</li> </ul> </li> </ul> </li> </ol> <p>By identifying and targeting these Six Big Losses, manufacturers can significantly improve their OEE and overall productivity.</p>"},{"location":"Project%20Knowledge/Machines/","title":"Overview of Machines at CMTI","text":""},{"location":"Project%20Knowledge/Machines/#introduction","title":"Introduction","text":"<p>This section will have information about the different machines available at cmti, such as their information model, method for getting data etc</p>"},{"location":"Project%20Knowledge/Machines/#mac-power-mono-200","title":"Mac Power Mono 200","text":"<p>The machine details are given below:</p> S.No Title Information 1 Machine Name Mac Power Mono 200 2. Machine Builder Mac Power 3. Model Mono 200 4. Type Turning Center 5. Controller Seimens 6. Controller Model 828D"},{"location":"Project%20Knowledge/Machines/#information-model","title":"Information Model","text":"<pre><code>1. ACTUAL_PART_COUNT_MONO-200\n2. Alarm\n    2.1. ALARM\n    2.2. ALARM_NUMBER_MONO-200\n    2.3. ALARM_TEXTINDEX_MONO-200\n    2.4. ALARM_TIME_MONO-200\n3. CNC\n    3.1. CNC_MODE_MONO-200\n    3.2. CNC_STATE_MONO-200\n4. CUTTING_TIME_MONO-200\n5. Cycle\n    5.1. CYCLE_RUNNING_MONO-200\n    5.2. CYCLE_START_PB_MONO-200\n    5.3. CYCLE_STOP_PB_MONO-200\n    5.4. CYCLE_TIME_MONO-200\n6. DISCONNECT\n7. Disconnect_MONO-200\n8. Emergency\n    8.1. EMERGENCY\n    8.2. EMERGENCY_SIGNAL_MONO-200\n9. MANUAL\n10. NC\n    10.1. NC_CHANNEL_RESET_MONO-200\n    10.2. NC_RUNNING_MONO-200\n    10.3. NC_STOP_MONO-200\n11. OPERATE\n12. OPERATING_TIME_MONO-200\n13. OperatorID\n14. PROG_NAME_MONO-200\n15. Product\n    15.1. ProductName\n    15.2. ProductResultNumber\n    15.3. ProductSerialNumber\n16. Servo\n    16.1. Feedrate\n        16.1.1. SERVO_AXIS_X_FEEDRATE_MONO-200\n        16.1.2. SERVO_AXIS_Z_FEEDRATE_MONO-200\n    16.2. Load\n        16.2.1. SERVO_DRIVE_LOAD_MONO-200\n    16.3. Position\n        16.3.1. SERVO_AXIS_X_POSITION_MONO-200\n        16.3.2. SERVO_AXIS_Z_POSITION_MONO-200\n17. Spindle\n    17.1. Load\n        17.1.1. SPINDLE_ACT_LOAD_MONO-200\n    17.2. Speed\n        17.2.1. SPINDLE_ACT_SPEED_MONO-200\n18. STOP\n19. SUSPEND\n20. TOOL_NO_MONO-200\n21. WARMUP\n22. WARNING\n</code></pre>"},{"location":"Project%20Knowledge/Machines/#ams-mcv-450","title":"AMS MCV - 450","text":"<p>The machine details are given below:</p> S.No Title Information 1. Machine Name AMS MCV - 450 2. Machine Builder AMS(ACE MANUFACTURING SYSTEMS) 3. Model MCV - 450 4. Type Milling Center 5. Controller Fanuc 6. Controller Model 0i - Mf Plus 7. Ip Address 172.18.30.147"},{"location":"Project%20Knowledge/Machines/#information-model_1","title":"Information Model","text":"<pre><code>1. ALARM\n2. Position\n1. Absolute Position\n    1. AbsPos_0_path1_MCV-450\n    2. AbsPos_1_path1_MCV-450\n    3. AbsPos_2_path1_MCV-450\n2. Relative Position\n    1. RelPos_0_path1_MCV-450\n    2. RelPos_1_path1_MCV-450\n    3. RelPos_2_path1_MCV-450\n3. Machine Position\n    1. McnPos_0_path1_MCV-450\n    2. McnPos_1_path1_MCV-450\n    3. McnPos_2_path1_MCV-450\n3. Comment\n    1. ActComment_path1_MCV-450\n4. Actual F\n    1. ActF_path1_MCV-450\n5. Actual FDec\n    1. ActFdec_path1_MCV-450\n6. Actual Program\n    1. ActProgram_path1_MCV-450\n7. Actual S\n    1. ActS_path1_MCV-450\n8. Battery\n    1. APC\n        1. Low (APC Battery Low APC could refer to automatic pallet changer - Automatic pallet changers are devices that transfer loads from one pallet to another in a fast and gentle way. They are used to increase productivity, efficiency and flexibility in various industries such as logistics, manufacturing, packaging and machining. Some CNC machines have automatic pallet changers that allow them to switch between different workpieces or parts without interrupting the machining process. This reduces the downtime and increases the output of the CNC machines. Doubt)\n            1. ApcBatLow_0_path1_MCV-450\n            2. ApcBatLow_1_path1_MCV-450\n            3. ApcBatLow_2_path1_MCV-450\n        2. Zero\n            1. ApcBatZero_0_path1_MCV-450\n            2. ApcBatZero_1_path1_MCV-450\n            3. ApcBatZero_2_path1_MCV-450\n    2. CNC \n        1. Low\n            1. CncBatLow_0_path1_MCV-450\n            2. CncBatLow_1_path1_MCV-450\n            3. CncBatLow_2_path1_MCV-450\n    3. Ind Bat Zero (InductoSync Battery Voltage)\n        1. IndBatZero_0_path1_MCV-450\n        2. IndBatZero_1_path1_MCV-450\n        3. IndBatZero_2_path1_MCV-450\n    4. S Spd Battery Zero (Serial Separate Detector Battery Voltage)\n        1. SSpdBatZero_0_path1_MCV-450\n        2. SSpdBatZero_1_path1_MCV-450\n        3. SSpdBatZero_2_path1_MCV-450\n    5. S Spd Battery Zero (Separate Detector Battery Voltage)\n        1. SpdBatZero_0_path1_MCV-450\n        2. SpdBatZero_1_path1_MCV-450\n        3. SpdBatZero_2_path1_MCV-450\n9. CNC Fan\n    1. Speed\n        1. CncFan1Speed_path1_MCV-450\n        2. CncFan2Speed_path1_MCV-450\n        3. CncFan3Speed_path1_MCV-450\n        4. CncFan4Speed_path1_MCV-450\n    2. Status\n        1. CncFan1Status_path1_MCV-450\n        2. CncFan2Status_path1_MCV-450\n        3. CncFan3Status_path1_MCV-450\n        4. CncFan4Status_path1_MCV-450\n10.  CNC State\n    1. CncState_path1_MCV-450\n11.  CNC Warning\n    1. CncWarning_path1_MCV-450\n12.  Cut Time\n    1. CutTime_path1_MCV-450\n13. DISCONNECT\n14. Disconnect_MCV-450\n15. EMERGENCY\n16. EMG_path1_MCV-450\n17.  Inside Fan\n    1. Spindle \n        1. Amp (In CNC (Computer Numerical Control) machines, a spindle amplifier is an electronic component that controls the speed and torque of the spindle motor. The spindle motor is a critical component of the machine, and its speed and torque must be carefully controlled during operation to achieve accurate cuts and other machining operations. The spindle amplifier is responsible for receiving signals from the CNC controller and converting them into the appropriate output signals to control the spindle motor. The amplifier typically uses pulse width modulation (PWM) to control the power delivered to the motor, and it may also use feedback from sensors to monitor and adjust the motor's speed and torque. The spindle amplifier may be integrated into the CNC machine's control system, or it may be a separate standalone component. The specific design and capabilities of the spindle amplifier can vary depending on the machine's requirements, but it is typically designed to provide precise control over the spindle motor's speed and torque, as well as protection against overloading and other potential issues. In summary, the spindle amplifier is an important component of CNC machines that plays a critical role in controlling the speed and torque of the spindle motor, which is essential for achieving accurate and precise machining operations. CNC machines often have a fan or other cooling system to help regulate the temperature of the spindle amplifier.)\n            1. Speed\n                1. InFan1SpindleAmpSpeed_0_path1_MCV-450\n                2. InFan2SpindleAmpSpeed_0_path1_MCV-450\n            2. Status\n                1. InFan1SpindleAmpStatus_0_path1_MCV-450\n                2. InFan2SpindleAmpStatus_0_path1_MCV-450\n        2. Com Pw (Common Power) (Spindle motor common power inside cooling fan)\n            1. Speed\n                1. InFan1SpdlComPwSpeed_0_path1_MCV-450\n                2. InFan2SpdlComPwSpeed_0_path1_MCV-450\n            2. Status\n                1. InFan1SpdlComPwStatus_0_path1_MCV-450\n                2. InFan2SpdlComPwStatus_0_path1_MCV-450\n    2. Servo \n        1. Amp \n            1. Speed\n                1. Fan 1\n                1. InFan1SrvAmpSpeed_0_path1_MCV-450\n                2. InFan1SrvAmpSpeed_1_path1_MCV-450\n                3. InFan1SrvAmpSpeed_2_path1_MCV-450\n                2. Fan 2\n                1. InFan2SrvAmpSpeed_0_path1_MCV-450\n                2. InFan2SrvAmpSpeed_1_path1_MCV-450\n                3. InFan2SrvAmpSpeed_2_path1_MCV-450\n            2. Status\n                1. Fan 1\n                1. InFan1SrvAmpStatus_0_path1_MCV-450\n                2. InFan1SrvAmpStatus_1_path1_MCV-450\n                3. InFan1SrvAmpStatus_2_path1_MCV-450\n                2. Fan 2\n                1. InFan2SrvAmpStatus_0_path1_MCV-450\n                2. InFan2SrvAmpStatus_1_path1_MCV-450\n                3. InFan2SrvAmpStatus_2_path1_MCV-450\n        2. Com Pw (Common Power) (Spindle motor common power inside cooling fan)\n            1. Speed\n                1. Fan 1\n                1. InFan1SrvComPwSpeed_0_path1_MCV-450\n                2. InFan1SrvComPwSpeed_1_path1_MCV-450\n                3. InFan1SrvComPwSpeed_2_path1_MCV-450\n                2. Fan 2\n                1. InFan2SrvComPwSpeed_0_path1_MCV-450\n                2. InFan2SrvComPwSpeed_1_path1_MCV-450\n                3. InFan2SrvComPwSpeed_2_path1_MCV-450\n            2. Status\n                1. Fan 1\n                1. InFan1SrvComPwStatus_0_path1_MCV-450\n                2. InFan1SrvComPwStatus_1_path1_MCV-450\n                3. InFan1SrvComPwStatus_2_path1_MCV-450\n                2. Fan 2\n                1. InFan2SrvComPwStatus_0_path1_MCV-450\n                2. InFan2SrvComPwStatus_1_path1_MCV-450\n                3. InFan2SrvComPwStatus_2_path1_MCV-450\n18. MANUAL\n19. Macro Variable\n    1. MacroVar_575_path1_MCV-450\n    2. MacroVar_576_path1_MCV-450\n20. Main Comment\n    1. MainComment_path1_MCV-450\n21. Main Program\n    1. MainProgram_path1_MCV-450\n22. Modal\n    1. ModalF_path1_MCV-450\n    2. ModalM2_path1_MCV-450\n    3. ModalM3_path1_MCV-450\n    4. ModalM_path1_MCV-450\n    5. ModalS_path1_MCV-450\n    6. ModalT_path1_MCV-450\n23. Mode\n    1. Mode_path1_MCV-450\n24. OPERATE\n25. OperatorID\n26. Override\n    1. Override_path1_MCV-450\n27. Total Number of parts Made\n    1. PartsNumAll_path1_MCV-450\n28. Parts made in this session (after the machine was turned on currently). Doubt\n    1. PartsNum_path1_MCV-450\n29. Power On time\n    1. PowOnTime_path1_MCV-450\n30. Product Data\n    1. Product Name\n        1. ProductName\n    2. Product Result Number\n        1. ProductResultNumber\n    3. Product Serial Number\n        1. ProductSerialNumber\n31. Encoder Temperature\n    1. PulseCoderTemp_0_path1_MCV-450\n    2. PulseCoderTemp_1_path1_MCV-450\n    3. PulseCoderTemp_2_path1_MCV-450\n32. Radiator Fan\n    1. Spdl \n        1. Amplifier\n            1. Speed\n                1. RadFan1SpindleAmpSpeed_0_path1_MCV-450\n                2. RadFan2SpindleAmpSpeed_0_path1_MCV-450\n            2. Status\n                1. RadFan1SpindleAmpStatus_0_path1_MCV-450\n                2. RadFan2SpindleAmpStatus_0_path1_MCV-450\n        2. Com Pw \n            1. Speed\n                1. RadFan1SpdlComPwSpeed_0_path1_MCV-450\n                2. RadFan2SpdlComPwSpeed_0_path1_MCV-450\n            2. Status\n                1. RadFan1SpdlComPwStatus_0_path1_MCV-450\n                2. RadFan2SpdlComPwStatus_0_path1_MCV-450\n    2. Servo \n        1. Amplifier \n            1. Speed\n                1. Fan 1\n                1. RadFan1SrvAmpSpeed_0_path1_MCV-450\n                2. RadFan1SrvAmpSpeed_1_path1_MCV-450\n                3. RadFan1SrvAmpSpeed_2_path1_MCV-450\n                2. Fan 2\n                1. RadFan2SrvAmpSpeed_0_path1_MCV-450\n                2. RadFan2SrvAmpSpeed_1_path1_MCV-450\n                3. RadFan2SrvAmpSpeed_2_path1_MCV-450\n            2. Status\n                1. Fan 1\n                1. RadFan1SrvAmpStatus_0_path1_MCV-450\n                2. RadFan1SrvAmpStatus_1_path1_MCV-450\n                3. RadFan1SrvAmpStatus_2_path1_MCV-450\n                2. Fan 2\n                1. RadFan2SrvAmpStatus_0_path1_MCV-450\n                2. RadFan2SrvAmpStatus_1_path1_MCV-450\n                3. RadFan2SrvAmpStatus_2_path1_MCV-450\n        2. Com Pw \n            1. Speed\n                1. Fan 1\n                1. RadFan1SrvComPwSpeed_0_path1_MCV-450\n                2. RadFan1SrvComPwSpeed_1_path1_MCV-450\n                3. RadFan1SrvComPwSpeed_2_path1_MCV-450\n                2. Fan 2\n                1. RadFan2SrvComPwSpeed_0_path1_MCV-450\n                2. RadFan2SrvComPwSpeed_1_path1_MCV-450\n                3. RadFan2SrvComPwSpeed_2_path1_MCV-450\n            2. Status\n                1. Fan 1\n                1. RadFan1SrvComPwStatus_0_path1_MCV-450\n                2. RadFan1SrvComPwStatus_1_path1_MCV-450\n                3. RadFan1SrvComPwStatus_2_path1_MCV-450\n                2. Fan 2\n                1. RadFan2SrvComPwStatus_0_path1_MCV-450\n                2. RadFan2SrvComPwStatus_1_path1_MCV-450\n                3. RadFan2SrvComPwStatus_2_path1_MCV-450\n33. Run Time\n    1. RunTime_path1_MCV-450\n34. STOP\n35. SUSPEND\n36. Sequence\n    1. Sequence_path1_MCV-450\n37. Servo\n    1. Current\n        1. Percentage (Servo Current Percentage parameter might be related to the servo current percentage of the Fanuc controller. Servo current is the amount of electric current that flows through the servo motor, which controls the movement of the machine axes. The parameter value might indicate how much of the maximum servo current is being used by the controller.)\n            1. ServoCurrentPer_0_path1_MCV-450\n            2. ServoCurrentPer_1_path1_MCV-450\n            3. ServoCurrentPer_2_path1_MCV-450\n        2. Value (Servo Current )\n            1. ServoCurrent_0_path1_MCV-450\n            2. ServoCurrent_1_path1_MCV-450\n            3. ServoCurrent_2_path1_MCV-450\n    2. Error\n        1. ServoError_0_path1_MCV-450\n        2. ServoError_1_path1_MCV-450\n        3. ServoError_2_path1_MCV-450\n38. Servo \n    1. Leak Resistance (Servo leak resistance is a measure of how much the servo motor resists unwanted movement or vibration when it is not powered. Maybe this parameter is used to calibrate or monitor the servo leak resistance of your machine. It could also be servo insulation resistance which is a measure of how well the servo motor is insulated from electric currents that could damage it or cause interference. Maybe this parameter is used to check or adjust the servo insulation resistance of your machine.)\n        1. ServoLeakResistData_0_path1_MCV-450\n        2. ServoLeakResistData_1_path1_MCV-450\n        3. ServoLeakResistData_2_path1_MCV-450\n    2. Load\n        1. ServoLoad_0_path1_MCV-450\n        2. ServoLoad_1_path1_MCV-450\n        3. ServoLoad_2_path1_MCV-450\n    3. Speed\n        1. ServoSpeed_0_path1_MCV-450\n        2. ServoSpeed_1_path1_MCV-450\n        3. ServoSpeed_2_path1_MCV-450\n    4. Temperature\n        1. ServoTemp_0_path1_MCV-450\n        2. ServoTemp_1_path1_MCV-450\n        3. ServoTemp_2_path1_MCV-450\n39. Signal Related Parameters (unknown)\n    1. SigAL_path1_MCV-450\n    2. SigCUT_path1_MCV-450\n    3. SigDM00_path1_MCV-450\n    4. SigDM01_path1_MCV-450\n    5. SigENB_0_path1_MCV-450\n    6. SigINP_0_path1_MCV-450\n    7. SigINP_1_path1_MCV-450\n    8. SigINP_2_path1_MCV-450\n    9. SigMDRN_path1_MCV-450\n    10. SigOP_path1_MCV-450\n    11. SigSBK_path1_MCV-450\n    12. SigSPL_path1_MCV-450\n    13. SigSTL_path1_MCV-450\n40. Spindle\n    1. Leak Resistance\n        1. SpindleLeakResistData_0_path1_MCV-450\n    2. Load\n        1. SpindleLoad_0_path1_MCV-450\n    3. Speed\n        1. SpindleSpeed_0_path1_MCV-450\n    4. Temperature\n        1. SpindleTemp_0_path1_MCV-450\n    5. Total Revolution\n        1. SpindleTotalRev1_0_path1_MCV-450\n        2. SpindleTotalRev2_0_path1_MCV-450\n41. WARMUP\n42. WARNING\n</code></pre>"},{"location":"Project%20Knowledge/Machines/#mazak-mazatech-h-400n","title":"Mazak Mazatech H-400N","text":"<p>The machine details are given below:</p> S.No Title Information 1. Machine Name Mazak Mazatech H-400N 2. Machine Builder Machine Builder 3. Model H-400 N (Mazatech line of machining centers) 4. Type Milling Machine 5. Controller Fanuc 6. Controller Type 0i -md series 7. Ip Address 172.18.30.157 8. Mac Address 00E0E41B3630 9. Application Layer for Communication Focas"},{"location":"Project%20Knowledge/Machines/#overview-of-mazak","title":"Overview of Mazak","text":"<p>Mazak is a prominent global manufacturer of machine tools, with a rich history dating back to its establishment in Japan in 1919. Over the years, the company has expanded its operations worldwide and has become a renowned name in the industry.</p>"},{"location":"Project%20Knowledge/Machines/#mazatech-precision-and-versatility-in-machining-centers","title":"Mazatech: Precision and Versatility in Machining Centers","text":"<p>Mazatech is a specialized product line within Mazak that focuses on the development and production of machining centers. These machines are highly regarded for their precision, versatility, and advanced features, making them suitable for a wide range of machining applications.</p>"},{"location":"Project%20Knowledge/Machines/#introducing-the-h-400n-machining-center","title":"Introducing the H-400N Machining Center","text":"<p>The H-400N is a specific model within the Mazatech line of machining centers. While detailed specifications about this particular model are not available due to the training data limitations up until September 2021, it is inferred that the H-400N is designed to handle medium to large-scale machining operations. It is likely optimized for high-speed and high-precision applications.</p>"},{"location":"Project%20Knowledge/Machines/#fanuc-leading-the-industry-in-cnc-systems","title":"Fanuc: Leading the Industry in CNC Systems","text":"<p>Fanuc is a well-known Japanese company specializing in the manufacturing of industrial robots, CNC systems, and factory automation solutions. They are a major supplier of CNC systems to various machine tool manufacturers, including Mazak.</p>"},{"location":"Project%20Knowledge/Machines/#exploring-the-fanuc-0i-md-series","title":"Exploring the Fanuc 0i -md Series","text":"<p>The 0i -md series refers to a specific family or generation of Fanuc CNC systems. The \"0i\" represents the overall series or platform, while the \"-md\" indicates its specific focus on milling and drilling applications. Fanuc 0i CNC systems are renowned for their reliability, user-friendly interface, and advanced capabilities, providing precise control over the machining process.</p>"},{"location":"Project%20Knowledge/Machines/#note-on-variations-and-updates","title":"Note on Variations and Updates","text":"<p>It is important to note that the specific capabilities, features, and technical specifications of the Mazak H-400N and the Fanuc 0i -md series may vary, as machine models and CNC systems often offer different configurations and options. For the most accurate and up-to-date information, it is recommended to consult the official Mazak and Fanuc websites or reach out to their representatives directly.</p>"}]}